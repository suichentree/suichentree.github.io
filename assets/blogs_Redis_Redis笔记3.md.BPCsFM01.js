import{_ as t,a as l}from"./chunks/redis20221010172434.DPFPk_0M.js";import{_ as n,c as e,o as p,ak as h}from"./chunks/framework.CmzJUe0_.js";const k="/assets/redis1653986956618.Dg9TK8It.png",r="/assets/redis_20230725104625.D00CQY1I.png",d="/assets/redis1653987103450.CTaZJOeC.png",o="/assets/redis1653984787383.C-4WSn2f.png",c="/assets/redis1653984822363.DPPpptjF.png",i="/assets/redis_20230725111509.DpeTaZFF.png",g="/assets/redis1653986474927.nlrTvee0.png",A="/assets/redis1653985987327.CM7xEI6Y.png",a="data:image/png;base64,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",F="data:image/png;base64,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",E="/assets/redis1653986172002.jNpHbViB.png",u="/assets/redis1653986328124.BCs_ecVu.png",y="/assets/redis1653986667228.CLzYdn4Z.png",b="/assets/redis1653986718554.lzF7-iCc.png",C="/assets/redis1653986642777.CnTY8l3e.png",m="/assets/redis_20230725140728.8L_EV7uy.png",B="/assets/redis1653985149557.DBsskhky.png",q="/assets/redis1653992091967.AlSMIpCl.png",D="/assets/redis_20230725142744.sKhmZ46o.png",v="/assets/redis1653986813240.BO4QZ82m.png",f="/assets/redis_20230725144112.6MQ4nMt9.png",_="/assets/redis1653986771309.jPbTdn4c.png",R="/assets/redis1653986877620.BP_K5KJq.png",z="/assets/redis1653992413406.B01cpG3h.png",L="/assets/redis1653985570612.BBM-vqi9.png",N="/assets/redis1653985497735.5pTdh2oM.png",x="/assets/redis1653985640422.B0xvkQJ_.png",S="/assets/redis1653985716275.K4y_LTJr.png",T="/assets/redis1653985743412.Dgbq2f7X.png",w="/assets/redis1653985824540.CgijAiOJ.png",O="/assets/redis_20230726134234.B7bTdZ6H.png",I="/assets/redis_20230726135040.Ddx4XNyf.png",J="/assets/redis_20230726143516.BEV5xG_k.png",P="/assets/reids_20230728094319.DnNhTa-B.png",W="/assets/redis_20230728094917.7mLhTT3s.png",j="/assets/redis_img_3.wbgA6PHh.png",G="/assets/redis1653574849336.BASnu_Ih.png",X="/assets/redis_20230727225302.Ffv8OeKk.png",Z="/assets/redis_20230727225845.DKgHA8_Y.png",M="/assets/redis1653577301737.CEgqD1BM.png",H="/assets/redis1653577349691.IVUawIJI.png",K="/assets/redis1653577445413.CtF0L7bY.png",U="/assets/redis1653577643629.DJzdX_Y_.png",V="/assets/redis1653577659166.Dn1JQ3uu.png",es=JSON.parse('{"title":"Redis笔记3","description":"","frontmatter":{"title":"Redis笔记3","date":"2023-07-24T00:00:00.000Z","sidebar":"auto","categories":["数据库"],"tags":["Redis"]},"headers":[],"relativePath":"blogs/Redis/Redis笔记3.md","filePath":"blogs/Redis/Redis笔记3.md"}'),Q={name:"blogs/Redis/Redis笔记3.md"};function Y($,s,ss,is,as,ts){return p(),e("div",null,s[0]||(s[0]=[h('<p>[toc]</p><h1 id="redis笔记3" tabindex="-1">Redis笔记3 <a class="header-anchor" href="#redis笔记3" aria-label="Permalink to &quot;Redis笔记3&quot;">​</a></h1><p>Redis 存在多种数据类型，比如字符串、列表、哈希散列等。不同数据类型的 value, 它们的底层结构也不相同。接下来介绍各个数据类型的底层原理。</p><h2 id="redis数据结构-redisobject" tabindex="-1">Redis数据结构-RedisObject <a class="header-anchor" href="#redis数据结构-redisobject" aria-label="Permalink to &quot;Redis数据结构-RedisObject&quot;">​</a></h2><p>Redis中的任意数据类型的键和值都会被封装为一个RedisObject，也叫做Redis对象，源码如下：</p><p><img src="'+k+`" alt="redis1653986956618"></p><blockquote><p>什么是redisObject？</p></blockquote><p>从Redis的使用者的角度来看，⼀个Redis节点包含多个database，而一个database维护了从key-value的映射关系。这个映射关系的key是string类型，⽽value可以是多种数据类型，比如：string, list, hash、set、sorted set等。我们可以看到，key的类型固定是string，而value可能的类型是多个。 ⽽从Redis内部实现的⾓度来看，key固定用⼀种数据结构来表达就够了，这就是动态字符串sds。而value则比较复杂，为了能够存储不同类型的value，这就需要⼀个通⽤的数据结构，这个通用的数据结构就是robj，全名是redisObject。</p><blockquote><p>Redis的底层存储结构</p></blockquote><p>Redis中会根据存储的数据类型不同，选择不同的底层存储结构，共包含11种不同类型：</p><table tabindex="0"><thead><tr><th><strong>编号</strong></th><th><strong>底层存储结构</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>0</td><td>OBJ_ENCODING_RAW</td><td>raw编码动态字符串</td></tr><tr><td>1</td><td>OBJ_ENCODING_INT</td><td>long类型的整数的字符串</td></tr><tr><td>2</td><td>OBJ_ENCODING_HT</td><td>hash表（字典dict）</td></tr><tr><td>3</td><td>OBJ_ENCODING_ZIPMAP</td><td>已废弃</td></tr><tr><td>4</td><td>OBJ_ENCODING_LINKEDLIST</td><td>双端链表</td></tr><tr><td>5</td><td>OBJ_ENCODING_ZIPLIST</td><td>压缩列表</td></tr><tr><td>6</td><td>OBJ_ENCODING_INTSET</td><td>整数集合</td></tr><tr><td>7</td><td>OBJ_ENCODING_SKIPLIST</td><td>跳表</td></tr><tr><td>8</td><td>OBJ_ENCODING_EMBSTR</td><td>embstr的动态字符串</td></tr><tr><td>9</td><td>OBJ_ENCODING_QUICKLIST</td><td>快速列表</td></tr><tr><td>10</td><td>OBJ_ENCODING_STREAM</td><td>Stream流</td></tr></tbody></table><blockquote><p>五种数据类型</p></blockquote><p>Redis中会根据存储的数据类型不同，选择不同的底层存储结构。每种数据类型的使用的底层存储结构如下：</p><table tabindex="0"><thead><tr><th><strong>数据类型</strong></th><th><strong>底层存储结构</strong></th></tr></thead><tbody><tr><td>OBJ_STRING</td><td>int、embstr、raw</td></tr><tr><td>OBJ_LIST</td><td>LinkedList和ZipList(3.2以前)、QuickList（3.2以后）</td></tr><tr><td>OBJ_SET</td><td>intset、HT</td></tr><tr><td>OBJ_ZSET</td><td>ZipList、HT、SkipList</td></tr><tr><td>OBJ_HASH</td><td>ZipList、HT</td></tr></tbody></table><h2 id="五种基础数据类型的存储结构" tabindex="-1">五种基础数据类型的存储结构 <a class="header-anchor" href="#五种基础数据类型的存储结构" aria-label="Permalink to &quot;五种基础数据类型的存储结构&quot;">​</a></h2><h3 id="string-字符串类型" tabindex="-1">string 字符串类型 <a class="header-anchor" href="#string-字符串类型" aria-label="Permalink to &quot;string 字符串类型&quot;">​</a></h3><p>Redis 使用标准C语言编写，但在存储字符串的时候，Redis并未使用C语言的字符类型，而是自定义了一个名为 SDS（Simple Dynamic String，简单动态字符串）的结构来存储字符串。</p><blockquote><p>新建一个string类型的键值对，发生了什么？</p></blockquote><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">set</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> java</span></span></code></pre></div><p>当你执行上面代码时。Redis将在底层创建两个SDS，其中一个是包含“name”的SDS，另一个是包含“java”的SDS。然后将这两个SDS关联起来。</p><blockquote><p>SDS的源码如下</p></blockquote><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sdshdr{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     //记录buf数组中已使用字符的数量，等于 SDS 保存字符串的长度</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> len;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     //记录 buf 数组中未使用的字符数量</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> free;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     //字符数组，用于保存字符串</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">     char</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> buf</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><img src="`+r+'" alt="redis_20230725104625.png"><img src="'+d+'" alt="redis1653987103450"></p><p>由源码可知，Redis的 string 类型是将字符串存储到字符数组buf[]中，并使用 len、free对buf[]数组的长度和未使用的字符数进行描述。</p><blockquote><p>SDS的特点？</p></blockquote><ul><li>获取字符串长度的时间复杂度为o(1)</li><li>支持动态扩容</li></ul><blockquote><p>SDS如何扩容？</p></blockquote><p>SDS之所以叫做动态字符串，是因为它具备动态扩容的能力。Redis 字符串允许的最大值字节数是 512 MB。</p><p>例如一个内容为“hi”的SDS： <img src="'+o+'" alt="redis1653984787383"></p><p>如果要给“hi”追加一段字符串“,Amy”，首先判断字符串中的未使用空间能够存储追加的字符串，如果不能则会申请新内存空间：</p><ul><li>如果新字符串小于1M，则新空间为扩展后字符串长度的两倍+1；</li><li>如果新字符串大于1M，则新空间为扩展后字符串长度+1M+1。称为内存预分配。</li></ul><p>扩容后，如图所示。 <img src="'+c+'" alt="redis1653984822363"></p><h3 id="list-列表类型" tabindex="-1">list 列表类型 <a class="header-anchor" href="#list-列表类型" aria-label="Permalink to &quot;list 列表类型&quot;">​</a></h3><p>Redis中的 list（列表数据类型）相当于 Java 语言中的 LinkedList 结构，是一个链表而非数组，其插入、删除元素的时间复杂度为 O(1)，但是查询速度欠佳，时间复杂度为 O(n)。</p><blockquote><p>底层存储结构</p></blockquote><p>Redis 列表的底层存储结构，其实是一个被称为快速链表（quicklist）的结构。</p><ul><li>当存储的元素较少时，Redis 会使用一块连续的内存来存储这些元素，这个连续的内存结构被称为 ziplist（压缩列表），它将所有的元素紧挨着一起存储。</li><li>当存储的元素较多时，Redis 列表就会是用 quicklist（快速链表）存储元素。quicklist是一个双端链表，只不过链表中的每个节点都是一个ziplist。</li></ul><p><span style="color:red;">redis在3.2版本之后，统一采用quicklist存储结构来实现List</span></p><p>简而言之，quicklist就是将多个 ziplist 使用双向指针串联起来，这样既能满足快速插入、删除的特性，又节省了一部分存储空间。quicklist结构如图所示。 <img src="'+i+'" alt="redis_20230725111509"><img src="'+g+'" alt="redis1653986474927"></p><h4 id="ziplist-压缩列表" tabindex="-1">ziplist (压缩列表) <a class="header-anchor" href="#ziplist-压缩列表" aria-label="Permalink to &quot;ziplist (压缩列表)&quot;">​</a></h4><p>ziplist 是一种特殊的“双端链表” ，由一系列特殊编码的连续内存块组成。可以在任意一端进行压入/弹出操作, 并且该操作的时间复杂度为 O(1)。</p><blockquote><p>ziplist 存储结构如图所示</p></blockquote><p><img src="'+A+'" alt="redis1653985987327"></p><p><img src="'+a+'" alt="redis1653986020491"></p><ul><li>zlbytes : 记录整个压缩列表占用的内存字节数</li><li>zltail : 记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，通过这个偏移量，可以确定表尾节点的地址。</li><li>zllen : 记录了压缩列表包含的节点数量。</li><li>entry : 压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</li><li>zlend : 用于标记压缩列表的末端。</li></ul><blockquote><p>zipList中的entry节点</p></blockquote><p>entry节点采用了下图的存储结构</p><p><img src="'+F+'" alt="redis1653986055253"></p><ul><li>previous_entry_length：前一节点的长度，占1个或5个字节。 <ul><li>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值</li><li>如果前一节点的长度大于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据</li></ul></li><li>encoding：编码属性，记录content的数据类型（字符串还是整数）以及长度，占用1个、2个或5个字节</li><li>contents：保存节点中存储的数据，可以是字符串或整数</li></ul><blockquote><p>entry节点中的encoding编码</p></blockquote><p>entry中的encoding编码分为字符串和整数两种。如果encoding是以“00”、“01”或者“10”开头，则证明content是字符串。否则是整数</p><p>例如保存字符串：“ab”和 “bc”</p><p><img src="'+E+'" alt="redis1653986172002"></p><blockquote><p>entry节点中的previous_entry_length</p></blockquote><p>每个entry都包含previous_entry_length来记录上一个节点的大小，长度是1个或5个字节：</p><ul><li>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值</li><li>如果前一节点的长度大于等于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据。</li></ul><blockquote><p>zipList的连续更新问题</p></blockquote><p>现在，假设我们有N个连续的、长度为250~253字节之间的entry，因此entry的previous_entry_length属性用1个字节即可表示，如图所示：</p><p><img src="'+u+'" alt="redis1653986328124"></p><p>zipList在这种特殊情况下产生的连续多次空间扩展操作称之为连锁更新（Cascade Update）。新增、删除都可能导致连锁更新的发生。</p><blockquote><p>总结：zipList特性</p></blockquote><ul><li>zipList压缩列表的可以看做一种连续内存空间的&quot;双向链表&quot;</li><li>列表的节点之间不是通过指针连接，而是记录上一节点和本节点长度来寻址，内存占用较低</li><li>如果列表数据过多，导致链表过长，可能影响查询性能</li><li>增或删较大数据时有可能发生连续更新问题</li></ul><h4 id="quicklist" tabindex="-1">quicklist <a class="header-anchor" href="#quicklist" aria-label="Permalink to &quot;quicklist&quot;">​</a></h4><p>当list存储的数据量过多，超出了zipList存储结构的最佳上限时，就容易触发ziplist的连续更新问题。我们可以将ziplist中的数据进行拆分。但是拆分又不方便管理和查找。于是为了解决上述种种问题，quicklist就出现了。</p><p>quicklist就是将多个ziplist使用双向指针串联起来的双向链表，quicklist的每个节点都是一个zipList。这样既能满足快速插入、删除的特性，又节省了一部分存储空间。</p><p><span style="color:red;">redis在3.2版本之后，统一采用quicklist存储结构来实现List</span></p><blockquote><p>quicklist的和quicklistNode的源码如图所示</p></blockquote><p><img src="'+y+'" alt="redis1653986667228"></p><blockquote><p>quicklist的存储结构如图所示</p></blockquote><p><img src="'+i+'" alt="redis_20230725111509"><img src="'+b+'" alt="redis1653986718554"></p><blockquote><p>quicklist的节点限制</p></blockquote><p>为了避免quickList中的每个zipList中entry节点过多，Redis提供了一个配置项：list-max-ziplist-size来限制。其默认值为-2。</p><ul><li>如果值为正，则代表zipList的允许的entry个数的最大值</li><li>如果值为负，则代表zipList的最大内存大小，分5种情况： <ul><li>-1：每个ZipList的内存占用不能超过4kb</li><li>-2：每个ZipList的内存占用不能超过8kb</li><li>-3：每个ZipList的内存占用不能超过16kb</li><li>-4：每个ZipList的内存占用不能超过32kb</li><li>-5：每个ZipList的内存占用不能超过64kb</li></ul></li></ul><p><img src="'+C+`" alt="redis1653986642777"></p><blockquote><p>quicklist的特点</p></blockquote><ul><li>是一个节点为ZipList的双端链表</li><li>节点采用ZipList，解决了传统链表的内存占用问题</li><li>控制了ZipList大小，解决连续内存空间申请效率问题</li><li>中间节点可以压缩，进一步节省了内存</li></ul><h3 id="set-集合类型" tabindex="-1">set 集合类型 <a class="header-anchor" href="#set-集合类型" aria-label="Permalink to &quot;set 集合类型&quot;">​</a></h3><p>set 集合类型遵循无序，唯一的规则，集合中的每一个成员都是字符串类型，并且不可重复。</p><p>set 集合类型采用了两种方式相结合的底层存储结构，分别是 intset（整型数组）与 hash table（哈希表），</p><ul><li>当 set 存储的数据满足以下要求时，使用 intset 结构： <ul><li>集合内保存的所有成员都是整数值；</li><li>集合内保存的成员数量不超过 512 个。</li></ul></li><li>当不满足上述要求时，则使用 hash table 结构。</li></ul><h4 id="intset-存储结构" tabindex="-1">intset 存储结构 <a class="header-anchor" href="#intset-存储结构" aria-label="Permalink to &quot;intset 存储结构&quot;">​</a></h4><blockquote><p>intset 的结构体定义如下</p></blockquote><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">typedf </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> inset{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> encoding;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //指定编码方式，默认为INSET_ENC_INT16</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    uint32_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> length;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    //集合内成员的总个数</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    int8_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> contents</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //实际存储成员的数组，并且数组中的数值从小到大依次排列</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}inset;</span></span></code></pre></div><ul><li>encoding：指定编码格式，共有三种，分别是 INTSET_ENC_INT16、INSET_ENC_INT32 和 INSET_ENC_INT64，它们对应不同的数值范围。它会根据插入数据的大小来选择不同的编码格式。</li><li>length：集合内成员的数量，记录 contents 数组中共有多少个成员。</li><li>contents：存储成员的数组，数组中的成员从小到大依次排列，且不允许重复。</li></ul><blockquote><p>intset 存储结构如图所示</p></blockquote><p><img src="`+m+'" alt="redis_20230725140728"><img src="'+B+'" alt="redis1653985149557"></p><blockquote><p>Intset的特点：</p></blockquote><ul><li>Redis会确保Intset中的元素唯一、有序</li><li>Intset类型升级机制，可以节省内存空间</li><li>底层采用二分查找方式来查询</li></ul><h3 id="zset-有序集合类型" tabindex="-1">zset 有序集合类型 <a class="header-anchor" href="#zset-有序集合类型" aria-label="Permalink to &quot;zset 有序集合类型&quot;">​</a></h3><p>zset（有序集合类型）中的成员是有序排列的，集合中的每一个成员都是字符串类型，并且不允许重复；zset是有序的，这是因为zset中每个成员都会关联一个score (分数值)，正是通过 score 实现了对zset中成员的排序。</p><p>zset中score可以重复。 <img src="'+q+'" alt="redis1653992091967"></p><p>zset（有序集合）使用了两种不同的底层存储结构，分别是 zipList（压缩列表）和 skipList（跳跃列表）。</p><p>当 zset 满足以下两个条件时使用zipList，否则使用skiplist作为存储结构。</p><ul><li>成员的数量小于128 个；</li><li>每个 member （成员）的字符串长度都小于 64 个字节。</li></ul><h4 id="ziplist-压缩列表-1" tabindex="-1">zipList（压缩列表） <a class="header-anchor" href="#ziplist-压缩列表-1" aria-label="Permalink to &quot;zipList（压缩列表）&quot;">​</a></h4><blockquote><p>zipList存储结构如图所示</p></blockquote><p><img src="'+a+'" alt="redis1653986020491"></p><ul><li>zlbytes : 记录整个压缩列表占用的内存字节数</li><li>zltail : 记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，通过这个偏移量，可以确定表尾节点的地址。</li><li>zllen : 记录了压缩列表包含的节点数量。</li><li>entry : 压缩列表包含的各个节点，节点的长度由节点保存的内容决定。</li><li>zlend : 用于标记压缩列表的末端。</li></ul><blockquote><p>例如 ZADD命令添加两个成员：xh（小红） 的工资是 3500.0；xm（小明） 的工资是 3200.0。</p></blockquote><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ZADD</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> salary</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3500.0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> xh</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3200.0</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> xm</span></span></code></pre></div><p><img src="'+D+'" alt="redis_20230725142744"></p><p>当添加完两个成员后，存储如图所示，zipList中的所有成员最终会按照 score 从小到大排列。</p><h4 id="skiplist-跳跃列表" tabindex="-1">skipList（跳跃列表） <a class="header-anchor" href="#skiplist-跳跃列表" aria-label="Permalink to &quot;skipList（跳跃列表）&quot;">​</a></h4><p>当zset不满足使用压缩列表的条件时，就会使用 skipList 结构来存储数据。</p><p>SkipList（跳表）首先是链表，但与传统链表相比有几点差异：</p><ul><li>元素按照升序排列存储</li><li>节点可能包含多个指针，指针跨度不同。</li></ul><blockquote><p>跳表的源码如图所示</p></blockquote><p><img src="'+v+'" alt="redis1653986813240"></p><ul><li>header：指向 skiplist 的头节点指针，通过它可以直接找到跳表的头节点，时间复杂度为 O(1)；</li><li>tail：指向 skiplist 的尾节点指针，通过它可以直接找到跳表的尾节点，时间复杂度为 O(1)；</li><li>length：记录 skiplist 的长度，也就跳表中有多少个元素，但不包括头节点；</li><li>level：记录当前跳表内所有节点中的最大层数（level）；</li></ul><p>跳跃列表的每一层都是一个有序的链表，链表中每个节点都包含两个指针，一个指向同一层的下了一个节点，另一个指向下一层的同一个节点。最低层的链表将包含 zset 中的所有元素。如果说一个元素出现在了某一层，那么低于该层的所有层都将包含这个元素，也就说高层是底层的子集。</p><blockquote><p>跳表的查询节点的过程</p></blockquote><p><img src="'+f+'" alt="redis_20230725144112"></p><p>跳跃列表中的每个节点都存储着 S:V（即 score/value），示意图显示了使用跳跃列表查找 S:V 节点的过程。跳跃列表的层数由高到低依次排列，最低层是 L0 层，最高层是 L3 层，共有 4 层。</p><p>图 1 所示，首先从最高层开始遍历找到第一个S:V节点，然后从此节点开始，逐层下降，通过遍历的方式找出每一层的 S:V 节点，直至降至最底层（L0）才停止。在这个过程中找到所有 S:V 节点被称为期望的节点。跳跃列表把上述搜索一系列期望节点的过程称为“搜索路径”，这个“搜索路径”由搜索到的每一层的期望节点组成，其本质是一个列表。</p><blockquote><p>跳表的存储结构如图所示</p></blockquote><p><img src="'+_+'" alt="redis1653986771309"><img src="'+R+'" alt="redis1653986877620"></p><blockquote><p>skipList的特点</p></blockquote><ul><li>跳跃表是一个双向链表，每个节点都包含score和ele值</li><li>节点按照score值排序，score值一样则按照ele字典排序</li><li>每个节点都可以包含多层指针，层数是1到32之间的随机数</li><li>不同层指针到下一个节点的跨度不同，层级越高，跨度越大</li><li>增删改查效率与红黑树基本一致，实现却更简单</li></ul><h3 id="hash-哈希散列类型" tabindex="-1">hash 哈希散列类型 <a class="header-anchor" href="#hash-哈希散列类型" aria-label="Permalink to &quot;hash 哈希散列类型&quot;">​</a></h3><p>hash（哈希散列）是由字符类型的 field（字段）和 value 组成的哈希映射表结构（也称散列表），它非常类似于表格结构。在 hash 类型中，field 与 value 一一对应，且不允许重复。</p><p>hash 特别适合于存储对象。一个 filed/value 可以看做是表格中一条数据记录；而一个 key 可以对应多条记录。</p><p>当 hash 类型移除最后一个元素后，该存储结构就会被自动删除，其占用内存也会被系统回收。</p><p><img src="'+t+'" alt="redis20221010151943.png"><img src="'+l+'" alt="redis20221010172434.png"></p><p>hash 类型底层存储结构有两种实现方式。</p><ul><li>第一种，hash 采用 ziplist 作为底层存储结构，此时要求符合以下两个条件： <ul><li>哈希对象保存的所有键值对（键和值）的字符串长度总和小于 64 个字节。</li><li>哈希对象保存的键值对数量要小于 512 个。</li></ul></li><li>当无法满足第一种的两个条件时，hash 就会采用 dict（字典结构）来存储数据，该结构类似于 Java 的 HashMap，是一个无序的字典，并采用了数组和链表相结合的方式存储数据。</li></ul><p><img src="'+z+'" alt="redis1653992413406"></p><h4 id="dict-字典结构" tabindex="-1">dict（字典结构） <a class="header-anchor" href="#dict-字典结构" aria-label="Permalink to &quot;dict（字典结构）&quot;">​</a></h4><p>Dict由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</p><p><img src="'+L+'" alt="redis1653985570612"></p><p>当我们向Dict添加键值对时，Redis首先根据key计算出hash值（h），然后利用 h &amp; sizemask来计算元素应该存储到数组中的哪个索引位置。我们存储k1=v1，假设k1的哈希值h =1，则1&amp;3 =1，因此k1=v1要存储到数组角标1位置。</p><p><img src="'+N+'" alt="redis1653985497735"></p><p><img src="'+x+'" alt="redis1653985640422"></p><blockquote><p>Dict的扩容</p></blockquote><p>Dict中的HashTable就是数组结合单向链表的实现，当集合中元素较多时，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。 Dict在每次新增键值对时都会检查负载因子（LoadFactor = used/size） ，满足以下两种情况时会触发哈希表扩容： 哈希表的 LoadFactor &gt;= 1，并且服务器没有执行 BGSAVE 或者 BGREWRITEAOF 等后台进程； 哈希表的 LoadFactor &gt; 5 ；</p><p><img src="'+S+'" alt="redis1653985716275"><img src="'+T+'" alt="redis1653985743412"></p><blockquote><p>Dict的rehash</p></blockquote><p>不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的size和sizemask变化，而key的查询与sizemask有关。因此必须对哈希表中的每一个key重新计算索引，插入新的哈希表，这个过程称为rehash。过程是这样的：</p><ul><li>计算新hash表的realeSize，值取决于当前要做的是扩容还是收缩： <ul><li>如果是扩容，则新size为第一个大于等于dict.ht[0].used + 1的2^n</li><li>如果是收缩，则新size为第一个大于等于dict.ht[0].used的2^n （不得小于4）</li></ul></li><li>按照新的realeSize申请内存空间，创建dictht，并赋值给dict.ht[1]</li><li>设置dict.rehashidx = 0，标示开始rehash</li><li>将dict.ht[0]中的每一个dictEntry都rehash到dict.ht[1]</li><li>将dict.ht[1]赋值给dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存</li><li>将rehashidx赋值为-1，代表rehash结束</li><li>在rehash过程中，新增操作，则直接写入ht[1]，查询、修改和删除则会在dict.ht[0]和dict.ht[1]依次查找并执行。这样可以确保ht[0]的数据只减不增，随着rehash最终为空</li></ul><p>整个过程可以描述成： <img src="'+w+'" alt="redis1653985824540"></p><blockquote><p>Dict的结构：</p></blockquote><ul><li>类似java的HashTable，底层是数组加链表来解决哈希冲突</li><li>Dict包含两个哈希表，ht[0]平常用，ht[1]用来rehash</li></ul><blockquote><p>Dict的伸缩：</p></blockquote><ul><li>当LoadFactor大于5或者LoadFactor大于1并且没有子进程任务时，Dict扩容</li><li>当LoadFactor小于0.1时，Dict收缩</li><li>扩容大小为第一个大于等于used + 1的2^n</li><li>收缩大小为第一个大于等于used 的2^n</li><li>Dict采用渐进式rehash，每次访问Dict时执行一次rehash</li><li>rehash时ht[0]只减不增，新增操作只在ht[1]执行，其它操作在两个哈希表</li></ul><h2 id="布隆过滤器" tabindex="-1">布隆过滤器 <a class="header-anchor" href="#布隆过滤器" aria-label="Permalink to &quot;布隆过滤器&quot;">​</a></h2><p>布隆过滤器（Bloom Filter）是 Redis 4.0 版本提供的新功能，它被作为插件加载到 Redis 服务器中，给 Redis 提供强大的去重功能。</p><blockquote><p>set集合和布隆过滤器的区别</p></blockquote><ul><li>两者都能对数据进行去重。</li><li>布隆过滤器相比set集合，在空间利用上节省90%以上。</li><li>布隆过滤器的去重率在99%以上，有1%左右的误判率。这种误差是由布隆过滤器的自身结构决定的。在某些场景下，</li></ul><blockquote><p>应用场景</p></blockquote><p>布隆过滤器是 Redis 的高级功能，虽然这种结构的去重率并不完全精确，但和其他结构一样都有特定的应用场景，比如当处理海量数据时，就可以使用布隆过滤器实现去重。</p><p>例如垃圾邮件过滤功能也采用了布隆过滤器。虽然在过滤的过程中，布隆过滤器会存在一定的误判，但比较于牺牲宝贵的性能和空间来说，这一点误判是微不足道的。</p><h3 id="工作原理" tabindex="-1">工作原理 <a class="header-anchor" href="#工作原理" aria-label="Permalink to &quot;工作原理&quot;">​</a></h3><p>布隆过滤器（Bloom Filter）是一个高空间利用率的概率性数据结构，由二进制向量（即位数组）和一系列随机映射函数（即哈希函数）两部分组成。</p><p>布隆过滤器使用exists()方法来判断某个元素是否存在于自身结构中。当布隆过滤器判定某个值存在时，其实这个值只是有可能存在；当它说某个值不存在时，那这个值肯定不存在，这个误判概率大约在 1% 左右。</p><blockquote><p>添加元素到布隆过滤器中</p></blockquote><p>布隆过滤器主要由位数组和一系列 hash 函数构成，其中位数组的初始状态都为 0。</p><p>当使用布隆过滤器添加 key 时，会使用不同的 hash 函数对 key 存储的元素值进行哈希计算，从而会得到多个哈希值。根据哈希值计算出一个整数索引值，将该索引值与位数组长度做取余运算，最终得到一个位数组位置，并将该位置的值变为 1。每个 hash 函数都会计算出一个不同的位置，然后把数组中与之对应的位置变为 1。通过上述过程就完成了元素添加(add)操作。</p><p><img src="'+O+`" alt="redis_20230726134234"></p><blockquote><p>判断元素是否存在</p></blockquote><p>当判断布隆过滤器中的一个元素是否存时，其流程如下：首先对给定元素再次执行哈希计算，得到与添加元素时相同的位数组位置，判断所得位置是否都为 1，如果其中有一个为 0，那么说明元素不存在，若都为 1，则说明元素有可能存在。</p><blockquote><p>为什么是可能“存在”</p></blockquote><p>为什么判断某个元素是有可能存在的？其实原因很简单，那些被置为 1 的位置也可能是由于其他元素的操作而改变的。比如，元素1 和 元素2，这两个元素同时将一个位置变为了 1（图1所示）。在这种情况下，我们就不能判定“元素 1”一定存在，这是布隆过滤器存在误判的根本原因。</p><h3 id="安装布隆过滤器" tabindex="-1">安装布隆过滤器 <a class="header-anchor" href="#安装布隆过滤器" aria-label="Permalink to &quot;安装布隆过滤器&quot;">​</a></h3><p>在 Redis 4.0 版本之后，布隆过滤器才作为插件被正式使用。布隆过滤器需要单独安装到redis上才能使用。</p><blockquote><p>docker安装</p></blockquote><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pull</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> redislabs/rebloom:latest</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -p</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 6379:6379</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --name</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> redis-redisbloom</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> redislabs/rebloom:latest</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">docker</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> exec</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -it</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> redis-redisbloom</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bash</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">redis-cli</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 测试是否安装成功</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">bf.add</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> www.biancheng.net</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> hello</span></span></code></pre></div><blockquote><p>安装包安装</p></blockquote><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 下载地址：</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">https://github.com/RedisBloom/RedisBloom</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 解压文件：</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">unzip</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> RedisBloom-master.zip</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 进入目录：</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> RedisBloom-master</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 执行编译命令，生成redisbloom.so 文件：</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">make</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 拷贝至指定目录：</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cp</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> redisbloom.so</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /usr/local/redis/bin/redisbloom.so</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 在redis配置文件里加入以下配置：</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">loadmodule</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /usr/local/redis/bin/redisbloom.so</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 配置完成后重启redis服务：</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /etc/init.d/redis-server</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> restart</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 测试是否安装成功</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">bf.add</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> www.biancheng.net</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> hello</span></span></code></pre></div><h3 id="使用布隆过滤器" tabindex="-1">使用布隆过滤器 <a class="header-anchor" href="#使用布隆过滤器" aria-label="Permalink to &quot;使用布隆过滤器&quot;">​</a></h3><blockquote><p>布隆过滤器常用命令</p></blockquote><p><img src="`+I+`" alt="redis_20230726135040.png"></p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">bf.add</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> spider:url</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> www.biancheng.net</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">bf.exists</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> spider:url</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> www.biancheng.net</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">bf.madd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> spider:url</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> www.taobao.com</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> www.123qq.com</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) 1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) 1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">bf.mexists</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> spider:url</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> www.jd.com</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> www.taobao.com</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) 0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) 1</span></span></code></pre></div><h2 id="redis事务" tabindex="-1">Redis事务 <a class="header-anchor" href="#redis事务" aria-label="Permalink to &quot;Redis事务&quot;">​</a></h2><p>Redis事务的目的是方便用户一次执行多个命令。可以把Redis的事务可以理解为一个批量执行Redis命令的脚本，但这个操作并非原子性操作，也就是说，如果中间某条命令执行失败，并不会导致前面已执行命令的回滚，同时也不会中断后续命令的执行（不包含监听 key 的情况）。</p><p>执行 Redis 事务可分为三个阶段：开始事务-》命令入队-》执行事务</p><blockquote><p>Redis事务的特征</p></blockquote><ul><li>事务在执行过的程中，不会被其他命令打断。</li><li>Redis事务，如果存在命令执行失败的情况，那么其他命令依然会被执行，不支持事务回滚机制。</li></ul><blockquote><p>事务命令</p></blockquote><p><img src="`+J+`" alt="redis_20230726143516.png"></p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 开启事务</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">MULTI</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">OK</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">INCR</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QUEUED</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> ## 命令入队成功</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">SET</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> num</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QUEUED</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 批量执行命令</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">EXEC</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) 1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) OK</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 开启事务之前设置key/value，并监听</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">set</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> www.biancheng.net</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> hello</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">OK</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">WATCH</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> www.biancheng.net</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">OK</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">get</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> www.biancheng.net</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">&quot;hello&quot;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 开启事务</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">MULTI</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">OK</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 更改key的value值</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">set</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> www.biancheng.net</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> HELLO</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QUEUED</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">GET</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> www.biancheng.net</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">QUEUED</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 命令执行失败</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">EXEC</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">EXECABORT</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Transaction</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> discarded</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> because</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> of</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> previous</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> errors.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 取消监听key</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">UNWATCH</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">OK</span></span></code></pre></div><h2 id="redis发布订阅" tabindex="-1">Redis发布订阅 <a class="header-anchor" href="#redis发布订阅" aria-label="Permalink to &quot;Redis发布订阅&quot;">​</a></h2><p>Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。用来传递消息的链路则被称为 channel。Redis客户端可以订阅任意数量的 channel（可译为频道）。</p><blockquote><p>发布订阅流程</p></blockquote><p><img src="`+P+'" alt="reids_20230728094319.png"></p><blockquote><p>发布订阅命令</p></blockquote><p><img src="'+W+`" alt="redis_20230728094917.png"></p><blockquote><p>例子</p></blockquote><ol><li>打开一个 Redis 客户端，订阅一个c1频道。订阅频道后，客户端会处于等待接收消息的阻塞状态。</li><li>重新开启另一个redis客户端，在c1频道发布消息，订阅者就能接收到消息。</li><li>回到之前的订阅频道的客户端，会发现该客户端接受了消息。</li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 先订阅一个c1 频道</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">subscribe</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> c1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Reading</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> messages...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (press </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Ctrl-C</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> to</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> quit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;subscribe&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;c1&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) 1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 再重新开启个redis客户端，然后在c1频道发布消息，订阅者就能接收到消息。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">publish</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> c1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;hello c1&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">### 再回到之前的订阅c1频道的redis客户端,会发现多出了几行信息。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">subscribe</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> c1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Reading</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> messages...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (press </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">Ctrl-C</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> to</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> quit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;subscribe&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;c1&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">integer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) 1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;message&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      ## 从这里开始就是另一个客户端向c1频道发布的信息</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;c1&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello c1&quot;</span></span></code></pre></div><p><img src="`+j+'" alt="3"></p><h2 id="redis消息队列" tabindex="-1">Redis消息队列 <a class="header-anchor" href="#redis消息队列" aria-label="Permalink to &quot;Redis消息队列&quot;">​</a></h2><h3 id="消息队列介绍" tabindex="-1">消息队列介绍 <a class="header-anchor" href="#消息队列介绍" aria-label="Permalink to &quot;消息队列介绍&quot;">​</a></h3><p>消息队列字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p><ul><li>队列：用于存储和管理消息的队列。</li><li>生产者：发送消息到消息队列</li><li>消费者：从消息队列获取消息并处理消息</li></ul><p><img src="'+G+'" alt="redis1653574849336"></p><blockquote><p>消息队列的好处</p></blockquote><p>举一个生活中的例子就是：快递员(生产者)把快递放到快递柜里边(消息队列)去，我们(消费者)从快递柜里边去拿东西。消息队列的存在将生产者和消费者分离开来。让它们不会互相影响，这就叫解耦。</p><p>虽然有许多现成的消息队列工具，比如kafka，rabbitmq等等，但是也可以直接使用redis提供的消息队列方案，降低部署和学习成本。</p><h3 id="stream-消息队列介绍" tabindex="-1">Stream 消息队列介绍 <a class="header-anchor" href="#stream-消息队列介绍" aria-label="Permalink to &quot;Stream 消息队列介绍&quot;">​</a></h3><p>Redis Stream 是 Redis 5.0 版本引入的一种新数据类型。实际上是一个具有消息发布/订阅功能的消息队列。</p><blockquote><p>stream消息队列结构如图所示</p></blockquote><p>Stream 消息队列主要由四部分组成，分别是：消息本身、生产者、消费者和消费组。 <img src="'+X+'" alt="redis_20230727225302.png"></p><p>Stream 消息队列中可以拥有多个消费组，每个消费组中又包含了多个消费者，组内消费者之间存在竞争关系。当某个消费者消费了一条消息时，同组消费者，都不会再次消费这条消息。被消费的消息 ID 会被放入等待处理的 Pending_ids 中。每消费完一条信息，消费组的游标就会向前移动一位，组内消费者就继续去争抢下消息。</p><blockquote><p>名词解释</p></blockquote><ul><li>Stream direction：表示数据流，它是一个消息链，将所有的消息都串起来，每个消息都有一个唯一标识 ID 和对应的消息内容。</li><li>Consumer Group ：表示消费组，使用 XGROUP CREATE 命令创建。一个 Stream 消息链上可以有多个消费组，一个消费组内拥有多个消费者，每一个消费者也有一个唯一的 ID 标识。</li><li>last_delivered_id ：表示消费组游标，每个消费组都会有一个游标 last_delivered_id，任意一个消费者读取了消息都会使游标 last_delivered_id 往前移动。</li><li>pending_ids ：表示消费者的状态变量，它记录了当前已经被客户端读取的消息 ID，但是这些消息没有被 ACK(确认字符)。如果客户端没有 ACK，那么这个变量中的消息 ID 会越来越多，一旦被某个消息被 ACK，它就开始减少。</li><li>ACK：即确认字符，接收方传递给发送方的一种传输类控制字符。表示发来的数据已确认接收无误。如果接收方成功的接收到数据，那么会回复一个 ACK 数据。</li></ul><blockquote><p>stream的优点</p></blockquote><p>Stream 除了拥有很高的性能和内存利用率外, 它最大的特点就是提供了消息的持久化存储，以及主从复制功能，从而解决了网络断开、Redis 宕机情况下，消息丢失的问题，即便是重启 Redis，存储的内容也会存在。</p><blockquote><p>stream常用命令</p></blockquote><p><img src="'+Z+'" alt="redis_20230727225845.png"></p><h3 id="使用-stream-消息队列" tabindex="-1">使用 stream 消息队列 <a class="header-anchor" href="#使用-stream-消息队列" aria-label="Permalink to &quot;使用 stream 消息队列&quot;">​</a></h3><p>发送消息的命令如图 <img src="'+M+'" alt="redis1653577301737"> 例如 <img src="'+H+'" alt="redis1653577349691"> 读取消息的方式之一：XREAD <img src="'+K+'" alt="redis1653577445413"> 例如，使用XREAD读取第一个消息 <img src="'+U+'" alt="redis1653577643629"> XREAD阻塞方式，读取最新的消息 <img src="'+V+'" alt="redis1653577659166"></p>',210)]))}const ps=n(Q,[["render",Y]]);export{es as __pageData,ps as default};
