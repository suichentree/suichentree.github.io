import{_ as i}from"./chunks/ruankao_20241023174341.C4ofU6QZ.js";import{_ as a,a as t}from"./chunks/ruankao_20250403160441.BSOu2sQ-.js";import{_ as p}from"./chunks/ruankao_20250403160058.CeiDXoaF.js";import{_ as l,c as n,o as e,ak as o}from"./chunks/framework.CmzJUe0_.js";const r="/assets/ruankao_20250523213723.CwELxSrf.png",h="/assets/ruankao_20250523230950.D1gNeBTZ.png",k="/assets/ruankao_20250523221600.Chyi_j-I.png",c="/assets/ruankao_20250523230322.BdhGi7uX.png",d="/assets/ruankao_20250523234620.NAYPLi8y.png",u="/assets/ruankao_20250523234850.PSuGZHKz.png",g="/assets/ruankao_20250524001943.r_JkezsW.png",_="/assets/ruankao_20250524002737.C5KL5mLR.png",b="/assets/ruankao_20250524003324.CofwDdG7.png",m="/assets/ruankao_20250523233442.CGopD6dw.png",E="/assets/ruankao_20250523235257.vpv6oZpf.png",q="/assets/ruankao_20250524000439.D9QtZ3Gf.png",y="/assets/ruankao_20250524010043.Bd4_LmpU.png",A="/assets/ruankao_20250524014452.Brrk9AEX.png",D="/assets/ruankao_20250524033159.BKIwPGmn.png",F="/assets/ruankao_20250524033332.CtR7cs3X.png",f="/assets/ruankao_20250524035100.Cpx-npi8.png",v="/assets/ruankao_20250524035158.DjQZRZXa.png",C="/assets/ruankao_20250524041923.EFBlo0pJ.png",x="/assets/ruankao_20250524042019.wVGwZLWJ.png",$=JSON.parse('{"title":"软件设计师笔记_应用大题_精简考点","description":"","frontmatter":{"title":"软件设计师笔记_应用大题_精简考点","date":"2025-05-22T00:00:00.000Z","sidebar":"auto","tags":["软考"]},"headers":[],"relativePath":"blogs/软考/软件设计师笔记_应用大题_精简考点.md","filePath":"blogs/软考/软件设计师笔记_应用大题_精简考点.md"}'),B={name:"blogs/软考/软件设计师笔记_应用大题_精简考点.md"};function P(j,s,R,w,L,S){return e(),n("div",null,s[0]||(s[0]=[o('<p>[toc]</p><h1 id="软件设计师笔记-应用大题-精简考点" tabindex="-1">软件设计师笔记_应用大题_精简考点 <a class="header-anchor" href="#软件设计师笔记-应用大题-精简考点" aria-label="Permalink to &quot;软件设计师笔记_应用大题_精简考点&quot;">​</a></h1><blockquote><p>科目二知识点分布</p></blockquote><table tabindex="0"><thead><tr><th>题号</th><th>题目类型</th><th>知识点</th><th>内容</th></tr></thead><tbody><tr><td>第1题</td><td>必答题</td><td>数据流图</td><td>补充数据流图的缺失部分</td></tr><tr><td>第2题</td><td>必答题</td><td>数据库设计</td><td>E-R模型，关系模式，增加实体等</td></tr><tr><td>第3题</td><td>必答题</td><td>UML建模</td><td>类图，用例图，活动图，状态图等</td></tr><tr><td>第4题</td><td>必答题</td><td>C语言算法</td><td>分治法，谈心法，动态规划法，回溯法等</td></tr><tr><td>第5题</td><td>选答题</td><td>C++程序设计</td><td>C++语法，设计模式</td></tr><tr><td>第6题</td><td>选答题</td><td>Java程序设计</td><td>Java语法，设计模式</td></tr></tbody></table><h2 id="第一题-数据流图" tabindex="-1">第一题 数据流图 <a class="header-anchor" href="#第一题-数据流图" aria-label="Permalink to &quot;第一题 数据流图&quot;">​</a></h2><p>补充数据流图的缺失部分</p><h3 id="基本" tabindex="-1">基本 <a class="header-anchor" href="#基本" aria-label="Permalink to &quot;基本&quot;">​</a></h3><p><img src="'+r+'" alt="ruankao_20250523213723.png"></p><blockquote><p>外部实体：是指在当前系统之外的实体。例如人，物品，其他系统等。</p></blockquote><p>图像用矩形表示。 英文一般用E1,E2表示。</p><p>举例的外部实体：</p><ul><li>人：学生，老师，医生，客户等</li><li>物品：传感器，车辆。</li><li>其他系统：支付系统，订单系统等</li></ul><blockquote><p>数据加工：是指输入流经过数据加工后变成输出流。</p></blockquote><p>圆矩形表示数据加工。英文一般用P1,P2来表示</p><p>一个数据加工至少由一个输入流和一个输出流。</p><ul><li>黑洞：是指只有输入没有输出的数据加工。</li><li>白洞：是指只有输出没有输入的数据加工。</li><li>灰洞：加工的输入数据不足以产生输出数据</li></ul><blockquote><p>数据存储：用于存储数据和取出数据。</p></blockquote><p>图像用缺口矩形表示。英文一般用D1 D2 表示。</p><p>例子：客户表，学生表，订单文件等</p><blockquote><p>数据流：表示数据的流向</p></blockquote><h3 id="做题总结" tabindex="-1">做题总结 <a class="header-anchor" href="#做题总结" aria-label="Permalink to &quot;做题总结&quot;">​</a></h3><blockquote><p>第一题：找出图中的实体名称。</p></blockquote><p>推荐参考 图2和题目说明，找到实体名称。所有的实体名称都在题目说明中出现过。</p><p>若发现图中有多个E1,E2,E3 那是为了方便设计数据流图而导致的。本质上多个E1是同样的。</p><blockquote><p>第二题：给出图中数据存储的名称</p></blockquote><p>推荐参考 图2和题目说明，找到数据存储的名称。</p><blockquote><p>第三题：补充缺失的数据流起点终点</p></blockquote><p>一般是一条数据流对应1-2分。根据分数补充多少条数据流。</p><p>缺失数据流的名称和起点终点都可以从说明中获取.</p><p>推荐的书写格式或机考格式如图所示</p><p><img src="'+h+'" alt="ruankao_20250523230950.png"></p><blockquote><p>有三种发现缺失的数据流的方法。</p></blockquote><ul><li>方法1：父图子图平衡。</li></ul><p>根据图1和图2中的数据流名称，看图2中是否有缺失的数据流。并根据图1的提示进行补充。</p><ul><li>方式2：加工既有输入数据流，也有输出数据流。</li></ul><p>看图2中的加工是否有输入和输出数据流。若没有则表示该加工缺失数据流，需要进行补充。</p><ul><li>方式3：数据守恒</li></ul><p>根据题目说明与图2进行详细对比，看图2的数据流是否符合题目说明。若不符合则缺少数据流，需要根据说明对图2进行补充。</p><p>==注意：数据流的起点或终点必须有一个是加工。==</p><h3 id="真题1" tabindex="-1">真题1 <a class="header-anchor" href="#真题1" aria-label="Permalink to &quot;真题1&quot;">​</a></h3><p>2014年上半年</p><p><img src="'+k+'" alt="ruankao_20250523221600.png"></p><p>【问题1】 使用说明中的词语，给出图1-1中的实体E1-E5的名称。</p><p>E1:巴士司机 E2:机械师 E3:会计 E4：主管 E5：库存管理系统</p><p>【问题2】 使用说明中的词语，给出图1-2中的数据存储D1-D4的名称</p><p>D1: 巴士列表文件 D2: 维修记录文件 D3: 部件清单 D4: 人事档案</p><p>【问题3】</p><p>补充图1-2中缺失的数据流及其起点和终点</p><p>答案：</p><p>3分表示有3条缺失的数据流。</p><p><img src="'+c+'" alt="ruankao_20250523230322.png"></p><h2 id="第二题-数据库设计" tabindex="-1">第二题 数据库设计 <a class="header-anchor" href="#第二题-数据库设计" aria-label="Permalink to &quot;第二题 数据库设计&quot;">​</a></h2><p>第二题 数据库设计一般考E-R模型，关系模式，增加实体等</p><h3 id="e-r-模型图" tabindex="-1">E-R 模型图 <a class="header-anchor" href="#e-r-模型图" aria-label="Permalink to &quot;E-R 模型图&quot;">​</a></h3><p>E-R 图中的主要构件如图所示。</p><ul><li>实体：用矩形表示。</li><li>属性：用椭圆表示。</li><li>联系：用菱形表示，分为一对一（1:1）、一对多（1:n）、多对多（m:n）。</li></ul><p><img src="'+i+'" alt="ruankao_20241023174341.png"></p><blockquote><p>弱实体</p></blockquote><p>弱实体用双边矩形表示。弱实体的存在必须以另一个实体为前提。例如实体A,B。只有当实体A存在的时候，实体B才会存在。那么实体B相对于实体A是弱实体。</p><p>如图只有当职工实体存在时，家属实体才存在。则家属实体为弱实体。 <img src="'+d+'" alt="ruankao_20250523234620.png"></p><blockquote><p>父子实体</p></blockquote><p>若实体A，B是父子关系。则实体A是实体B的父实体。</p><p>如图所示。职员实体和其他三个实体的关系是父子关系。 <img src="'+u+'" alt="ruankao_20250523234850.png"></p><p>==父子实体的联系需要加上小圆圈表示。子实体是用类似橡皮擦的图案表示。==</p><h3 id="关系模式和指出主键外键" tabindex="-1">关系模式和指出主键外键 <a class="header-anchor" href="#关系模式和指出主键外键" aria-label="Permalink to &quot;关系模式和指出主键外键&quot;">​</a></h3><ul><li>关系模式的格式为：关系名（属性1，属性2，属性3 .。。。。。。。）</li><li>主键：唯一属性</li><li>外键：联系其他关系的属性。</li></ul><p>==构建关系模式，可以理解为设计表==</p><blockquote><p>如何将一对一关系转换为关系模式（参考一对一表的设计）</p></blockquote><p>方式1</p><ol><li>先将实体和属性转换为关系。</li><li>再将联系也转换为关系。</li></ol><p>方式2</p><ol><li>先将实体和属性转换为关系。</li><li>再选择其中一个实体的主键属性，加入到另一个关系的属性中。</li></ol><p>如图所示 <img src="'+g+'" alt="ruankao_20250524001943.png"></p><blockquote><p>如何将一对多关系转换为关系模式（参考一对多表的设计，添加外键）</p></blockquote><p>方式1</p><ol><li>先将实体和属性转换为关系。</li><li>再将联系也转换为关系。其中多的那方为主键。</li></ol><p>方式2</p><ol><li>先将实体和属性转换为关系。</li><li>选择少的实体的主键属性，加入到多的实体的关系中，作为外键属性。</li></ol><p><img src="'+_+'" alt="ruankao_20250524002737.png"></p><blockquote><p>如何将多对多关系转换为关系模式（参考多对多表的设计，设计中间表）</p></blockquote><ol><li>先将实体和属性转换为关系。</li><li>再将联系也转换为关系。将两个实体的主键都作为属性添加到关系中即可。</li></ol><p><img src="'+b+'" alt="ruankao_20250524003324.png"></p><h3 id="第一问-补充e-r图" tabindex="-1">第一问：补充E-R图 <a class="header-anchor" href="#第一问-补充e-r图" aria-label="Permalink to &quot;第一问：补充E-R图&quot;">​</a></h3><p>如图是18年下半年的真题例子 <img src="'+m+'" alt="ruankao_20250523233442.png"></p><p>一般根据需求分析结果将E-R图进行补充。注意联系的名称如果没要求可以从需求分析结果中摘取。</p><p>答案如图所示 <img src="'+E+'" alt="ruankao_20250523235257.png"></p><h3 id="第二问-补充关系模式-指出主键和外键" tabindex="-1">第二问：补充关系模式，指出主键和外键 <a class="header-anchor" href="#第二问-补充关系模式-指出主键和外键" aria-label="Permalink to &quot;第二问：补充关系模式，指出主键和外键&quot;">​</a></h3><p>即根据问题一的E-R图转换为对应的关系模式。</p><p>如图所示，将关系模式中的a-c补充完整。 <img src="'+q+'" alt="ruankao_20250524000439.png"></p><p>==注意一个空可能要填多个属性。不光要从文字说明中找到对应属性，也要从E-R图中根据对应关系添加对应属性。==</p><p>答案</p><p><img src="'+y+'" alt="ruankao_20250524010043.png"></p><h2 id="第三题-uml建模" tabindex="-1">第三题 UML建模 <a class="header-anchor" href="#第三题-uml建模" aria-label="Permalink to &quot;第三题 UML建模&quot;">​</a></h2><h3 id="基本-1" tabindex="-1">基本 <a class="header-anchor" href="#基本-1" aria-label="Permalink to &quot;基本&quot;">​</a></h3><h4 id="关系" tabindex="-1">关系 <a class="header-anchor" href="#关系" aria-label="Permalink to &quot;关系&quot;">​</a></h4><p>UML 中有四种关系:依赖，关联，泛化，实现。</p><blockquote><p>依赖关系</p></blockquote><p>依赖：一个事物的语义依赖于另一个事物的语义的变化而变化的关系。</p><p>如图所示各个关系的画图 <img src="'+a+'" alt="ruankao_20241023160820.png"></p><p>用虚线箭头表示，箭头起点是依赖事物，箭头终点是被依赖事物。若A依赖于B，则A在箭头起点，B在箭头终点。</p><blockquote><p>关联关系</p></blockquote><p>关联：是一种结构关系，描述了整体和部分之间的关系。</p><p>有两个特殊的关联关系。</p><ul><li>聚合：整体和部分的生命周期不一样。整体消失了，部分任然可以存在。两者是独立的。</li><li>组合：整体和部分的生命周期一样，整体消失了，部分也会消失。</li></ul><p>如图所示各个关系的画图 <img src="'+a+'" alt="ruankao_20241023160820.png"></p><p>普通的关联关系用实线表示。聚合关系用白色菱形箭头表示。组合关系用黑色菱形箭头表示。</p><p>注意起点代表部分，菱形代表整体。</p><p>关联关系上的0..1表示0个或1个。0..*表示0个或多个。</p><blockquote><p>泛化关系</p></blockquote><p>泛化：一般/特殊的关系，子类和父类之间的关系。</p><p>如图所示各个关系的画图 <img src="'+a+'" alt="ruankao_20241023160820.png"></p><p>泛化关系用实线三角箭头表示。箭头起点为子类，三角箭头终点为父类。</p><blockquote><p>实现关系（很少考）</p></blockquote><p>实现：一个类元指定了另一个类元保证执行的契约。类似接口和实现类的关系。</p><p>如图所示各个关系的画图 <img src="'+a+'" alt="ruankao_20241023160820.png"></p><p>实现关系用虚线三角箭头表示。箭头起点为实现类，三角箭头终点为接口类。</p><h4 id="图" tabindex="-1">图 <a class="header-anchor" href="#图" aria-label="Permalink to &quot;图&quot;">​</a></h4><blockquote><p>类图</p></blockquote><p>类图：展现一组对象、接口、协作和它们之间的关系。</p><p>如图所示 <img src="'+A+'" alt="ruankao_20250524014452.png"><img src="'+p+'" alt="ruankao_20250403160058.png"></p><blockquote><p>用例图</p></blockquote><p>用例图展现了一组用例、参与者和它们之间的关系。</p><ul><li>参与者是指人、硬件或其他系统可以扮演的角色。用小人展示。</li><li>用例是指参与者完成的一系列操作。用椭圆展示</li><li>用例之间的关系是指 包含（必须要做）、扩展（可做可不做）、泛化等。用各种箭头表示。</li></ul><p><img src="'+t+'" alt="ruankao_20250403160441.png"></p><blockquote><p>包含关系</p></blockquote><p>标注<code>&lt;&lt;include&gt;&gt;</code>的虚线箭头表示。箭头起点为包含用例。箭头终点为被包含用例。</p><p>例如A --include --&gt; B。就是A包含B的意思。</p><blockquote><p>扩展关系</p></blockquote><p>标注<code>&lt;&lt;extend&gt;&gt;</code>的虚线箭头表示。</p><blockquote><p>泛化关系</p></blockquote><p>三角箭头表示泛化关系。表示父类和子类的关系。</p><h3 id="第一问-补充用例图" tabindex="-1">第一问 补充用例图 <a class="header-anchor" href="#第一问-补充用例图" aria-label="Permalink to &quot;第一问 补充用例图&quot;">​</a></h3><p>一般是补充用例图中的用例（用椭圆表示）。用例是指参与者完成的一些操作。补充用例就是补充操作。</p><p>一般根据说明来猜出用例图中缺失的部分。</p><h3 id="第二问-补充类图" tabindex="-1">第二问 补充类图 <a class="header-anchor" href="#第二问-补充类图" aria-label="Permalink to &quot;第二问 补充类图&quot;">​</a></h3><p>一般来说是补充类图。可以根据说明中用英文标注的单词。推测出每个单词表示一个类。</p><ol><li>先找出类图中的具有父类子类关系和接口实现类的关系。</li><li>然后根据说明中描述的数量关系，来与类图中的类进行一一比对。</li><li>从而将类图中的类与说明中的名词进行绑定。</li></ol><p>例如文字说明中机器人有两种类型，表示机器人这个类有两个子类。机器人有两个传感器功能，表示机器人有一个传感器接口，该接口有两个实现类。</p><p>==注意类图中的实心箭头图表示泛化关系，也就是父类子类关系。==</p><p>也有可能通过第三问的题干，推出第二题的答案。</p><h3 id="例题" tabindex="-1">例题 <a class="header-anchor" href="#例题" aria-label="Permalink to &quot;例题&quot;">​</a></h3><blockquote><p>21年下</p></blockquote><p><img src="'+D+'" alt="ruankao_20250524033159.png"><img src="'+F+'" alt="ruankao_20250524033332.png"></p><blockquote><p>21年上</p></blockquote><p><img src="'+f+'" alt="ruankao_20250524035100.png"><img src="'+v+'" alt="ruankao_20250524035158.png"></p><blockquote><p>19年下</p></blockquote><p><img src="'+C+'" alt="ruankao_20250524041923.png"><img src="'+x+`" alt="ruankao_20250524042019.png"></p><h2 id="第四题-算法题" tabindex="-1">第四题 算法题 <a class="header-anchor" href="#第四题-算法题" aria-label="Permalink to &quot;第四题 算法题&quot;">​</a></h2><h2 id="第五题-第六题-二选一-c-程序设计-java程序设计" tabindex="-1">第五题 第六题 二选一 C++程序设计 java程序设计 <a class="header-anchor" href="#第五题-第六题-二选一-c-程序设计-java程序设计" aria-label="Permalink to &quot;第五题 第六题 二选一 C++程序设计 java程序设计&quot;">​</a></h2><p>主要考补全代码，程序填空题。</p><h3 id="java程序设计" tabindex="-1">java程序设计 <a class="header-anchor" href="#java程序设计" aria-label="Permalink to &quot;java程序设计&quot;">​</a></h3><p>闹记关键字</p><blockquote><p>类</p></blockquote><p>继承类的关键字为 extends</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	String name;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> B</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> age;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>抽象类和抽象方法</p></blockquote><p>抽象类的关键字：abstract</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">abstract</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> A</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> abstract</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> show</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();   </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//抽象方法show</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><blockquote><p>接口</p></blockquote><p>接口的关键字：interface implements</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//用interface关键字声明接口</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	 void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> show</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//抽象方法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//用implements关键字实现接口C</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> D</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> implements</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> show</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {    </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//对接口的重写</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		System.out.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">println</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;show&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>根据类图中的箭头图案，推测出类之间的关系。并推测出对应的代码 <img src="`+a+'" alt="ruankao_20241023160820.png"></p>',162)]))}const N=l(B,[["render",P]]);export{$ as __pageData,N as default};
