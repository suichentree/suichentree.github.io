import{_ as a,c as e,o,ak as d}from"./chunks/framework.CmzJUe0_.js";const r="/assets/mysql_20231217150646.DFOJj5_K.png",t="/assets/mysql_20231217161337.DELo3z9Z.png",_="/assets/mysql_20231217163152.rcPJQrDo.png",n="/assets/mysql_20231217211318.BDhWanNk.png",p="/assets/mysql_20231217212004.jMB2D3qM.png",s="/assets/mysql_20231217214148.BuYcV71H.png",l="/assets/mysql_20231217220227.2elyl-vi.png",g=JSON.parse('{"title":"MySQL笔记14-MVCC","description":"","frontmatter":{"title":"MySQL笔记14-MVCC","date":"2022-12-16T00:00:00.000Z","sidebar":"auto","categories":["数据库"],"tags":["MySql"]},"headers":[],"relativePath":"blogs/MySQL/MySQL笔记14-MVCC.md","filePath":"blogs/MySQL/MySQL笔记14-MVCC.md"}'),c={name:"blogs/MySQL/MySQL笔记14-MVCC.md"};function m(u,i,h,x,V,R){return o(),e("div",null,i[0]||(i[0]=[d('<p>[toc]</p><h1 id="mysql笔记14-mvcc" tabindex="-1">MySQL笔记14-MVCC <a class="header-anchor" href="#mysql笔记14-mvcc" aria-label="Permalink to &quot;MySQL笔记14-MVCC&quot;">​</a></h1><h2 id="什么是mvcc" tabindex="-1">什么是MVCC？ <a class="header-anchor" href="#什么是mvcc" aria-label="Permalink to &quot;什么是MVCC？&quot;">​</a></h2><p>MVCC全称是多版本并发控制 (Multi-Version Concurrency Control)。</p><h2 id="为什么要有mvcc" tabindex="-1">为什么要有MVCC？ <a class="header-anchor" href="#为什么要有mvcc" aria-label="Permalink to &quot;为什么要有MVCC？&quot;">​</a></h2><p>在数据库中，当多事务（多线程）并发访问同一个数据的时候，我们通常使用锁来保证线程的安全性。</p><p>但是由于读锁和写锁是具有互斥性的。因此只有读读之间的操作才可以让多线程并发执行。读写，写读，写写操作都只能让一个线程执行，其余线程进入阻塞状态。这样就会导致MySQL的并发性能极差。</p><p>而数据库使用MVCC机制后，可以让多线程在读写，写读操作中并发执行。虽然写写操作还是相互阻塞，但是能够大大提高了MySQL的并发性能。</p><p>即：</p><ul><li>使用MVCC之前：读读并发执行。读写，写读，写写阻塞。</li><li>使用MVCC之后：读读，读写，写读并发执行。写写阻塞。</li></ul><p>小结：MVCC可以让数据库在并发执行读写操作的时候，读写操作不互相阻塞。从而提高了数据库的并发性能。</p><h2 id="mvcc的实现原理" tabindex="-1">MVCC的实现原理 <a class="header-anchor" href="#mvcc的实现原理" aria-label="Permalink to &quot;MVCC的实现原理&quot;">​</a></h2><p>MVCC的实现原理主要是通过 隐藏字段,undo-log 日志,ReadView 来实现的。</p><h3 id="隐藏字段" tabindex="-1">隐藏字段 <a class="header-anchor" href="#隐藏字段" aria-label="Permalink to &quot;隐藏字段&quot;">​</a></h3><p>对于使用 InnoDB 存储引擎的表来说，每个表都有隐藏字段。如下</p><ul><li>DB_ROW_ID字段： 隐藏主键ID字段。如果表没有设置主键字段，InnoDB会创建DB_ROW_ID字段作为主键字段。</li><li>DB_TRX_ID : 写事务ID字段。如果一个事务对行记录进行了写操作（插入/更新/删除），那么这个字段会记录这个写事务的ID。如果是读操作，那么记录的事务ID是0。</li><li>IDDB_ROLL_PTR : 回滚指针字段。指向这条记录的上一个版本。</li></ul><p>如图所示 <img src="'+r+'" alt="mysql_20231217150646.png"></p><h3 id="undo-log-日志" tabindex="-1">undo-log 日志 <a class="header-anchor" href="#undo-log-日志" aria-label="Permalink to &quot;undo-log 日志&quot;">​</a></h3><p>当数据库对行记录进行写操作（插入/更新/删除）的时候。为了保证事务回滚的时候，能够还原行记录。因此数据库会生成一个undo-log日志，然后把行记录的数据保存到undo-log日志中，然后再对行记录进行写操作。当事务进行回滚的时候，数据库就读取undo日志中的行记录，来进行数据还原。</p><p>undo日志分为3种：</p><ul><li>Insert undo-log ：插入一条行记录时，先把这条记录的主键值记下来，之后事务回滚的时候把这个主键值对应的记录删掉即可。</li><li>Update undo-log：修改一条行记录时，先把修改这条记录前的旧值都记录下来，之后事务回滚时再用旧值替换新值即可。</li><li>Delete undo-log：删除一条记录时，先把这条记录保存下来，之后事务回滚时再把记录插入到表中即可。</li></ul><h3 id="undo-log日志链" tabindex="-1">undo-log日志链 <a class="header-anchor" href="#undo-log日志链" aria-label="Permalink to &quot;undo-log日志链&quot;">​</a></h3><p>由于事务对行记录进行写操作的时候，数据库会生成一个undo-log日志记录事务对行记录的操作。</p><p>当多个事务并发操作同一条行记录的时候，数据库会为每一个事务创建一个undo-log日志。并将这些事务对行记录的操作按事务执行的先后顺序和链表的方式，将每个事务的undo-log日志串连起来。形成了一个undo-log日志链。这个undo-log日志链，记录了这条行记录的所有版本信息。</p><p>例如：有一个表，表中已经存在一条记录。有两个事务id分别为100，200的事务对某条记录进行写操作。</p><p><img src="'+t+'" alt="mysql_20231217161337.png"></p><p>图中的刘备数据，是由ID为80的事务插入到数据库的，是行记录最初的信息。 <img src="'+_+'" alt="mysql_20231217163152.png"></p><p>如上图所示，每次对行记录进行改动，数据库都会生成一个undo日志,undo日志记录了行记录的版本信息。所有的undo日志都通过roll_pointer指针互相连接起来，串成一个undo日志链表。</p><h3 id="readview" tabindex="-1">ReadView <a class="header-anchor" href="#readview" aria-label="Permalink to &quot;ReadView&quot;">​</a></h3><p>当一个事务对行记录进行读操作的时候，由于undo-log日志链中存在行记录的各个版本信息。那么这个读事务该读取行记录那个版本呢？</p><p>因此数据库提供了一个ReadView的概念。用于判断事务应该读取undo-log日志链中的哪个版本。</p><p>PS:当一个事务读取行记录的时候，数据库会为该事务创建一个ReadView。ReadView有四个重要的参数。</p><h4 id="readview的四个参数" tabindex="-1">ReadView的四个参数 <a class="header-anchor" href="#readview的四个参数" aria-label="Permalink to &quot;ReadView的四个参数&quot;">​</a></h4><ul><li>creator_trx_id：是指创建这个ReadView的事务的trx_id。</li><li>m_ids：是指在创建ReadView时，当前系统中活跃的事务的ID集合 (“活跃&quot;是指事务启动了但还没提交)。可以理解为undo-log日志链中所有未提交事务的ID集合。</li><li>min_trx_id：是指最小的事务id。也就是 m_ids 中的最小值。</li><li>max_trx_id：表示生成 ReadView 时，系统中应该分配给下一个事务的 id 值。</li></ul><h4 id="对creator-trx-id的详细解释" tabindex="-1">对creator_trx_id的详细解释 <a class="header-anchor" href="#对creator-trx-id的详细解释" aria-label="Permalink to &quot;对creator_trx_id的详细解释&quot;">​</a></h4><p>当某个事务对行记录进行写操作的时候，数据库才会为这个事务分配一个事务id。如果这个事务一直都是读操作的话，那么数据库不会为这个事务分配事务ID，即只读只读事务中的事务id都默认为0。</p><p>例如一个事务A，先读，再写，再读。</p><ol><li>事务A第一次读的时候，数据库不会为事务A分配id,即id默认为0。此时事务A的ReadView的creator_trx_id是0。</li><li>当事务A再写的时候，数据库会为事务A分配id,例如100。</li><li>当事务A再读的时候，此时事务A的ReadView的creator_trx_id是100。</li></ol><h4 id="对max-trx-id-的详细解释" tabindex="-1">对max_trx_id 的详细解释 <a class="header-anchor" href="#对max-trx-id-的详细解释" aria-label="Permalink to &quot;对max_trx_id 的详细解释&quot;">​</a></h4><p>max_trx_id并不是m_ids中的最大值。例如undo-log日志链中有id为1，2，3这三个未提交事务。</p><p>当id为3的事务提交后。那么一个新的读事务在生成ReadView时，m_ids就包括1和2，min_trx_id的值是1，max_trx_id的值就是4。</p><p>一般而言，max_trx_id就是m_ids的最大值+1</p><h4 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h4><p>当一个事务读取行记录的时候。数据库会为该事务创建一个ReadView。通过这个ReadView来判断这个事务，应该读取这个行记录所对应的undo-log日志链中哪一个版本数据。</p><h3 id="readview的可见性判断算法" tabindex="-1">ReadView的可见性判断算法 <a class="header-anchor" href="#readview的可见性判断算法" aria-label="Permalink to &quot;ReadView的可见性判断算法&quot;">​</a></h3><p>当一个事务读取行记录的时候。数据库会为该事务创建一个ReadView。通过这个ReadView来判断这个事务，应该读取这个行记录所对应的undo-log日志链中哪一个版本数据。</p><p>打个比方：有一个事务A要读取一个行记录R1，这个行记录R1有对应的undo-log日志链。并且数据库会为事务A创建一个ReadView。</p><blockquote><p>判断步骤如下：</p></blockquote><ol><li>事务A首先读取undo-log日志链中的第一个版本节点（最新版本数据）。</li><li>然后事务A将节点的 trx_id 与 事务A的ReadView进行对比。</li><li>对比方式是ReadView的可见性判断算法。如下文。</li><li>如果通过可见性判断算法，判断出事务A不能读取该节点。那么事务A开始读取undo-log日志链中的下一个节点。然后进入到步骤2，依次类推。</li><li>最后如果事务A都不能读取undo-log日志链中所有的节点。那么表示事务A无法读取该行记录。</li></ol><p>小结：即事务A依次读取undo-log日志链中每个节点的数据，并判断该节点数据能否被事务A读取。从头节点到尾节点开始判断，直到找到能读取的节点为止。如果所有节点都不能被事务A可见。那么表示事务A不能读取这条行记录，查询结果就不包含该行记录。</p><blockquote><p>可见性判断算法如下：</p></blockquote><p>注意：trx_id是指undo-log日志链表中某个版本节点的trx_id。事务A是指当前读事务。</p><ol><li>当 trx_id = creator_trx_id 时，表示这个版本节点的数据是该事务A修改的，因此这个节点对于事务A可见。</li><li>当 trx_id &lt; min_trx_id 时: 表示这个节点已经被其他事务提交了。因此该节点的trx_id不在m_ids数组中。因此这个节点对于事务A可见。</li><li>当 trx_id &gt;= max_trx_id 时: 表示这个节点是在事务A创建ReadView之后出现的。因此这个节点对于事务A不可见。</li><li>当 min_trx_id &lt;= trx_id &lt; max_trx_id 时：有两个情况。 <ol><li>trx_id 在 m_ids 列表里面：表示该节点数据还没有被事务提交，那么事务A不能读取未提交节点数据。则表示该节点对于事务A不可见。</li><li>trx_id 不在 m_ids 列表里面: 表示该节点已经被事务提交了，因此事务A可以读取该节点数据。则表示该节点对于事务A可见。</li></ol></li></ol><h2 id="mvcc和隔离级别的关系" tabindex="-1">MVCC和隔离级别的关系 <a class="header-anchor" href="#mvcc和隔离级别的关系" aria-label="Permalink to &quot;MVCC和隔离级别的关系&quot;">​</a></h2><p>数据库事务有四种隔离级别，其中读已提交和可重复读这两个隔离级别与MVCC相关。即读已提交和可重复读这两个隔离级别的实现方式就是通过MVCC来实现的。</p><p>读已提交和可重复读这两个隔离级别，它们最大的区别是内部的MVCC机制中生成ReadView的时机不同。</p><ul><li>读已提交：事务A在每次读取行记录的时候，都会生成一个新的ReadView。</li><li>可重复读：事务A只在第一次读取行记录的时候，会生成一个ReadView。之后事务A再次读取行记录，都会复用第一次生成的ReadView。</li></ul><p>注意：不同事务生成的ReadView是独立的。即事务A和事务B生成的ReadView不能混用。</p><h3 id="读已提交中的mvcc-每次生成新的readview" tabindex="-1">读已提交中的MVCC-每次生成新的ReadView <a class="header-anchor" href="#读已提交中的mvcc-每次生成新的readview" aria-label="Permalink to &quot;读已提交中的MVCC-每次生成新的ReadView&quot;">​</a></h3><p>若事务是读已提交的隔离级别，那么MVCC机制会在事务每次读取行记录的时候，都会生成一个新的ReadView。</p><h4 id="模拟多事务执行流程" tabindex="-1">模拟多事务执行流程 <a class="header-anchor" href="#模拟多事务执行流程" aria-label="Permalink to &quot;模拟多事务执行流程&quot;">​</a></h4><blockquote><p>假设1: 目前有一个行记录R1，该记录中name字段的值为<code>小明</code>。该记录是由已提交事务80插入到表中的。 假设2: 现在有四个事务，同时并发读写这个行记录R1。事务执行顺序如下表所示。</p></blockquote><p>事务100，200，300，400的执行顺序如下表所示 <img src="'+n+'" alt="mysql_20231217211318.png"></p><p>模拟多事务并发的流程如下：</p><ol><li>首先经过了T1,T2,T3时刻。此时行记录R1的undo-log日志链如下图所示。</li></ol><p><img src="'+p+'" alt="mysql_20231217212004.png.png"></p><ol start="2"><li><p>当来到T4时刻，事务300要读取行记录R1。读取流程如下：</p><ol><li>事务300读取行记录R1的时候，由于事务300的读已提交隔离级别。数据库会为事务300生成一个ReadView。这个ReadView的m_ids = [100,200], min_trx_id = 100, max_trx_id = 201, creator_trx_id = 0 。并且由于事务300第一次是读操作，所以数据库没有为事务300分配事务id,所以creator_trx_id的值为0。</li><li>然后事务300开始读取undo-log日志链的第一个节点（头节点，最新版本）。</li><li>由于第1个节点的trx_id为200，在m_ids数组中。即该节点数据未被事务提交。所以该节点对于事务300不可见。根据roll_pointer指针,读取下一个节点。</li><li>由于第2个节点的trx_id为100，在m_ids数组中。即该节点数据未被事务提交。所以该节点对于事务300不可见。根据roll_pointer指针,读取下一个节点。</li><li>由于第3个节点的trx_id为100，在m_ids数组中。即该节点数据未被事务提交。所以该节点对于事务300不可见。根据roll_pointer指针,读取下一个节点。</li><li>由于第4个节点的trx_id为80，不在m_ids数组中。并且80 &lt; min_trx_id。表示这个节点的数据在事务300生成ReadView之前，就已经被事务80提交了。所以该节点对于事务300可见。</li><li>最后事务300读取行记录R1的结果就是小明。</li></ol></li><li><p>当经过了T5,T6时刻。此时行记录R1的undo-log日志链如下图所示。</p></li></ol><p>T5时刻事务100提交。T6时刻事务300修改行记录R1。 <img src="'+s+'" alt="mysql_20231217214148.png"></p><ol start="4"><li><p>当来到T7时刻，事务400要读取行记录R1。读取流程如下：</p><ol><li>事务400在读取行记录R1的时候，由于事务400的读已提交隔离级别。数据库会为事务400重新生成一个ReadView。此时这个ReadView的m_ids = [200,300], min_trx_id = 200, max_trx_id = 301, creator_trx_id = 0 。</li><li>然后事务400开始读取undo-log日志链的第一个节点。</li><li>由于第1个节点的trx_id为300，在m_ids数组中。即该节点数据未被事务提交。所以该节点对于事务400不可见。根据roll_pointer指针,读取下一个节点。</li><li>由于第2个节点的trx_id为200，在m_ids数组中。即该节点数据未被事务提交。所以该节点对于事务400不可见。根据roll_pointer指针,读取下一个节点。</li><li>由于第3个节点的trx_id为100，不在m_ids数组中。并且100 &lt; min_trx_id。表示这个节点的数据在事务400生成ReadView之前，就已经被事务100提交了。所以该节点对于事务400可见。</li><li>最后事务400读取行记录R1的结果就是B。</li></ol></li><li><p>当经过了T8,T9时刻。此时行记录R1的undo-log日志链如下图所示。</p></li></ol><p>T8时刻事务200修改行记录R1。T9时刻事务200提交。 <img src="'+l+'" alt="mysql_20231217220227.png.png"></p><ol start="6"><li>当来到T10时刻，事务300要读取行记录R1。读取流程如下： <ol><li>事务300在读取行记录R1的时候，由于事务300的读已提交隔离级别。数据库会为事务300重新生成一个ReadView。此时这个ReadView的m_ids = [300], min_trx_id = 300, max_trx_id = 301, creator_trx_id = 300 。由于此时的事务300之前进行了写操作，所以数据库为事务300分配了事务id，所以creator_trx_id = 300。</li><li>然后事务300开始读取undo-log日志链的第一个节点。</li><li>由于第1个节点的trx_id为200，不在m_ids数组中。并且200 &lt; min_trx_id。表示这个节点的数据在事务300生成ReadView之前，就已经被事务200提交了。所以该节点对于事务300可见。</li><li>最后事务300读取行记录R1的结果是E。</li></ol></li></ol><h3 id="可重复读中的mvcc-每次使用第一次生成的readview" tabindex="-1">可重复读中的MVCC-每次使用第一次生成的ReadView <a class="header-anchor" href="#可重复读中的mvcc-每次使用第一次生成的readview" aria-label="Permalink to &quot;可重复读中的MVCC-每次使用第一次生成的ReadView&quot;">​</a></h3><p>若事务是可重复读的隔离级别，那么MVCC机制会在事务每次读取行记录的时候，每次复用该事务第一次生成的ReadView。</p><p>注意：ReadView中的creator_trx_id 不会被复用。</p><h4 id="模拟多事务执行流程-1" tabindex="-1">模拟多事务执行流程 <a class="header-anchor" href="#模拟多事务执行流程-1" aria-label="Permalink to &quot;模拟多事务执行流程&quot;">​</a></h4><p>可重复读的MVCC模拟过程与读已提交的MVCC模拟过程前面相同。并且这两个模拟过程的undo-log日志链是相同的。</p><p>模拟多事务并发的流程如下：</p><ol><li>T4时刻, 事务300第一次读行记录R1的分析和结果与上文相同。</li><li>T7时刻, 事务400第一次读行记录R1的分析和结果与上文相同。</li><li>当经过了T8,T9时刻。此时行记录R1的undo-log日志链如下图所示。</li></ol><p>T8时刻事务200修改行记录R1。T9时刻事务200提交。 <img src="'+l+'" alt="mysql_20231217220227.png.png"></p><ol start="4"><li>当来到T10时刻。事务300要读取行记录R1。读取流程如下： <ol><li>事务300在读取行记录R1的时候，由于事务300是可重复读隔离级别，因此事务300的ReadView是之前第一次生成的ReadView。即这个ReadView的m_ids = [100,200], min_trx_id = 100, max_trx_id = 201, creator_trx_id = 300。由于此时的事务300之前进行了写操作，所以数据库为事务300分配了事务id，所以creator_trx_id = 300。</li><li>然后事务300开始读取undo-log日志链的第一个节点。</li><li>由于第1个节点的trx_id为200，在m_ids数组中。所以该节点对于事务300不可见。根据roll_pointer指针,读取下一个节点。</li><li>由于第2个节点的trx_id为300，300 = creator_trx_id 。因此表示这个节点是由当前事务300更改的。因此该节点对于事务300可见/</li><li>最后事务300读取行记录R1的结果是D。</li></ol></li></ol><h2 id="什么是当前读和快照读" tabindex="-1">什么是当前读和快照读 <a class="header-anchor" href="#什么是当前读和快照读" aria-label="Permalink to &quot;什么是当前读和快照读&quot;">​</a></h2><p>有了MVCC机制，可以让数据库的读写操作并发执行，即读写操作不互斥了。</p><ul><li><p>当前读：当数据库执行<code>select lock in share mode(共享锁), select for update ; update, insert ,delete </code>等SQL操作的时候，数据库会对读取的记录进行加锁，从而确保其他并发事务不能修改当前记录。</p></li><li><p>快照读：对于不加锁的select操作就是快照读，即不加锁的非阻塞读。快照读的实现方式就是MVCC(多版本并发控制)。</p></li></ul>',83)]))}const q=a(c,[["render",m]]);export{g as __pageData,q as default};
