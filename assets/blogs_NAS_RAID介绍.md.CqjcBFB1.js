import{_ as r,c as i,o as e,ak as t}from"./chunks/framework.CmzJUe0_.js";const p="/assets/raid_20230615134113.CI2mk2Ni.png",A="/assets/raid_20230615135313.BbAXH6l6.png",D="/assets/raid_20230615140236.Df5xHCxZ.png",I="/assets/raid_20230615140746.CWpIQfC9.png",_=JSON.parse('{"title":"RAID介绍","description":"","frontmatter":{"title":"RAID介绍","date":"2023-06-15T00:00:00.000Z","sidebar":"auto","categories":["NAS"]},"headers":[],"relativePath":"blogs/NAS/RAID介绍.md","filePath":"blogs/NAS/RAID介绍.md"}'),d={name:"blogs/NAS/RAID介绍.md"};function o(s,a,R,l,n,h){return e(),i("div",null,a[0]||(a[0]=[t('<p>[toc]</p><h1 id="raid介绍" tabindex="-1">RAID介绍 <a class="header-anchor" href="#raid介绍" aria-label="Permalink to &quot;RAID介绍&quot;">​</a></h1><p>RAID （ Redundant Array of Independent Disks ）即独立磁盘冗余阵列，简称为「磁盘阵列」，本质上就是用多个独立的磁盘组成在一起形成一个大的磁盘系统，从而实现比单块磁盘更好的存储性能和更高的可靠性。</p><p>RAID方案常见的可以分为：</p><ul><li>RAID0</li><li>RAID1</li><li>RAID3</li><li>RAID5</li><li>RAID6</li><li>RAID10</li></ul><h2 id="raid0" tabindex="-1">RAID0 <a class="header-anchor" href="#raid0" aria-label="Permalink to &quot;RAID0&quot;">​</a></h2><p>RAID0 是一种非常简单的的方式，它将多块磁盘组合在一起形成一个大容量的存储。当我们要写数据的时候，首先会将数据分为N份，然后同时并发的写到多块磁盘中。当我们要读取数据的时候，会从多块磁盘上同时并发的读取出来。因此执行性能非常的高。</p><p>简单来说：RAID0存储数据的方式是将一份文件拆分开，并发写到所有硬盘上，RAID0读取数据的方式是从所有硬盘中并发读取数据。</p><p><img src="'+p+'" alt="raid_20230615134113.png"></p><p>RAID0的优点：RAID0的读写性能理论上是单块磁盘的N倍（理论上，实际中磁盘的寻址时间也是性能占用的大头）</p><p>RAID0的缺点：RAID0并不提供数据校验或冗余备份，因此一旦组成RAID0的一块磁盘损坏了，数据就直接丢失，无法恢复了。因此RAID0就不可能用于高要求的业务中，但可以用在对可靠性要求不高，对读写性能要求高的场景中。</p><h2 id="raid1" tabindex="-1">RAID1 <a class="header-anchor" href="#raid1" aria-label="Permalink to &quot;RAID1&quot;">​</a></h2><p><img src="'+A+'" alt="raid_20230615135313.png"></p><p>RAID1 是磁盘阵列中单位成本最高的一种方式。因为它的原理是在往磁盘写数据的时候，将同一份数据无差别的写两份到磁盘，分别写到工作磁盘和镜像磁盘，那么它的实际空间使用率只有50%了，两块磁盘当做一块用，这是一种比较昂贵的方案。</p><p>优点：数据的安全性非常强，除非组成RAID1的两块硬盘同时坏掉。</p><p>缺点：成本非常高，读写性能也不强。</p><h2 id="raid3" tabindex="-1">RAID3 <a class="header-anchor" href="#raid3" aria-label="Permalink to &quot;RAID3&quot;">​</a></h2><p>RAID3用的很少.</p><p>RAID3的方式是：将数据按照RAID0的形式，分成多份同时写入多块磁盘，但是还会另外再留出一块磁盘用于写「奇偶校验码」。例如总共有N块磁盘，那么就会让其中额度N-1块用来并发的写数据，第N块磁盘用记录校验码数据。一旦某一块磁盘坏掉了，就可以利用其它的N-1块磁盘去恢复数据。</p><p>但是由于第N块磁盘是校验码磁盘，因此有任何数据的写入都会要去更新这块磁盘，导致这块磁盘的读写是最频繁的，也就非常的容易损坏。</p><h2 id="raid5" tabindex="-1">RAID5 <a class="header-anchor" href="#raid5" aria-label="Permalink to &quot;RAID5&quot;">​</a></h2><p>RAID5是在RAID3的基础上进行了改进。不再需要用单独的磁盘写校验码了,它把校验码信息分布到各个磁盘上。</p><p>例如，总共有N块磁盘，那么会将要写入的数据分成N份，并发的写入到N块磁盘中，同时还将数据的校验码信息也写入到这N块磁盘中（数据与对应的校验码信息必须得分开存储在不同的磁盘上）。一旦某一块磁盘损坏了，就可以用剩下的硬盘和对应的奇偶校验码信息去恢复损坏的数据。</p><p><img src="'+D+'" alt="raid_20230615140236.png"></p><p>RAID5的方式，最少需要三块磁盘来组建磁盘阵列，允许最多同时坏一块磁盘。如果有两块磁盘同时损坏了，那数据就无法恢复了。</p><h2 id="raid6" tabindex="-1">RAID6 <a class="header-anchor" href="#raid6" aria-label="Permalink to &quot;RAID6&quot;">​</a></h2><p>RAID6在RAID5的基础上再次改进，引入了双重校验的概念。可以在有两块磁盘同时损坏的情况下，也能保障数据可恢复。</p><p>RAID6除了每块磁盘上都有同级数据校验区以外，还有针对每个数据块的校验区，这样的话，相当于每个数据块有两个校验保护措施，因此数据的冗余性更高了。</p><p>但是RAID6的这种设计也带来了很高的复杂度，虽然数据冗余性好，读取的效率也比较高，但是写数据的性能就很差。因此RAID6在实际环境中应用的比较少。</p><h2 id="raid10" tabindex="-1">RAID10 <a class="header-anchor" href="#raid10" aria-label="Permalink to &quot;RAID10&quot;">​</a></h2><p>RAID10 其实就是RAID1 + RAID0</p><p>如果有四块硬盘，那么先对硬盘进行RAID1，然后再进行RAID0</p><p><img src="'+I+'" alt="raid_20230615140746.png"></p><p>RAID10兼备了RAID1和RAID0的优点。首先基于RAID1模式将磁盘分为2份，当要写入数据的时候，将所有的数据在两份磁盘上同时写入，相当于写了双份数据，起到了数据保障的作用。且在每一份磁盘上又会基于RAID0技术讲数据分为N份并发的读写，这样也保障了数据的读写效率。</p><p>但也可以看出RAID10模式是有一半的磁盘空间用于存储冗余数据的，浪费的很严重，因此用的也不是很多。</p><h2 id="raid和jbod区别" tabindex="-1">RAID和JBOD区别 <a class="header-anchor" href="#raid和jbod区别" aria-label="Permalink to &quot;RAID和JBOD区别&quot;">​</a></h2><p>JBOD（Just a bunch of disk）严格上来说不是一种RAID，因为它只是简单将多个磁盘合并成一个大的逻辑盘，并没有任何的数据冗余。数据的存放机制就是从第一块磁盘开始依序向后存储数据。如果某个磁盘损毁，则该盘上的数据就会丢失。</p>',37)]))}const u=r(d,[["render",o]]);export{_ as __pageData,u as default};
