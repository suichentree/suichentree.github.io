import{_ as i,c as a,o as e,ak as t}from"./chunks/framework.CmzJUe0_.js";const n="/assets/redis20221012170247.CuCnOENT.png",l="/assets/redis20221014104144.DJt9i6BT.png",p="/assets/redis20221014104417.CQXOxL8a.png",h="/assets/redis20221014104829.BDPTf8ra.png",r="/assets/redis20221014105251.Do2vUTPk.png",d="/assets/redis20221014105547.DcpHAMIZ.png",k="/assets/redis_img_4.D_8AsfB2.png",o="/assets/redis_img_5.DHdRAgM8.png",c="/assets/redis_img_6.BJtAleC0.png",g="/assets/redis20221014155055.6QNo5_nf.png",F="/assets/redis20221014155319.DC9ZLEFk.png",y="/assets/redis20221014155420.DfLhLZBq.png",b="/assets/redis20221014155500.1L_F1Dee.png",u="/assets/redis20221014155540.aesZ-Hxk.png",m="/assets/redis20221014155712.BSHgWFre.png",C="/assets/redis_20230727105444.Cc8pJFgT.png",B="/assets/redis20221014161423.Dq65t6KY.png",A="/assets/redis_20230727110028.YtT1f7Hz.png",v="/assets/redis20221014161617.B3Sof15U.png",f="/assets/redis_20230727134103.Zbf5DW4p.png",D="/assets/redis20221014163639.BiPoIs_A.png",q="/assets/redis20221014152738.CGRZqida.png",_="/assets/redis20221014152945.CyeAWgmL.png",E="/assets/redis20221014153037.Dxlo5xCg.png",R="/assets/redis20221014153134.Dvd6eEOG.png",x="/assets/redis20221014153258.hrEMhK6m.png",M=JSON.parse('{"title":"Redis笔记4","description":"","frontmatter":{"title":"Redis笔记4","date":"2023-07-25T00:00:00.000Z","sidebar":"auto","categories":["数据库"],"tags":["Redis"]},"headers":[],"relativePath":"blogs/Redis/Redis笔记4.md","filePath":"blogs/Redis/Redis笔记4.md"}'),O={name:"blogs/Redis/Redis笔记4.md"};function P(S,s,T,w,V,G){return e(),a("div",null,s[0]||(s[0]=[t(`<p>[toc]</p><h1 id="redis笔记4" tabindex="-1">Redis笔记4 <a class="header-anchor" href="#redis笔记4" aria-label="Permalink to &quot;Redis笔记4&quot;">​</a></h1><h2 id="redis的持久化" tabindex="-1">Redis的持久化 <a class="header-anchor" href="#redis的持久化" aria-label="Permalink to &quot;Redis的持久化&quot;">​</a></h2><p>Redis 是一款基于内存的非关系型数据库，它会将数据全部存储在内存中。但是如果 Redis 服务器出现某些意外情况，比如宕机或者断电等，那么内存中的数据就会全部丢失。因此必须有一种机制能够保证 Redis 储存的数据不会因故障而丢失，这就是 Redis 的数据持久化机制。</p><p>持久化会把存储在内存的数据放到硬盘上。即使在服务器发生故障之后，也能通过本地磁盘对数据进行恢复。</p><p>Redis 提供了两种持久化方案：第一种是 RDB，又称快照（snapshot）模式，第二种是 AOF 日志，也就追加模式。</p><h3 id="rdb快照模式持久化" tabindex="-1">RDB快照模式持久化 <a class="header-anchor" href="#rdb快照模式持久化" aria-label="Permalink to &quot;RDB快照模式持久化&quot;">​</a></h3><p>RDB （全称Redis Database Backup ）即快照模式，它是 Redis 默认的数据持久化方式，简单来说就是把内存中的数据都存储到dump.rdb文件中。当Redis实例故障重启后，就从磁盘读取dump.rdb文件，恢复数据。</p><h4 id="rdb持久化的使用" tabindex="-1">RDB持久化的使用 <a class="header-anchor" href="#rdb持久化的使用" aria-label="Permalink to &quot;RDB持久化的使用&quot;">​</a></h4><p>在redis中，有两种方式来触发RDB持久化。一种是手动触发，另一种是自动触发。</p><p><span style="color:red;">注意：Redis在停机时会自动执行一次save命令，实现RDB持久化。</span></p><blockquote><p>手动触发</p></blockquote><p>手动触发是通过SAVAE命令或者BGSAVE命令将内存数据保存到磁盘中。命令执行后，将在Redis安装目录中创建dump.rdb文件。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 对当前数据库进行数据备份</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">SAVE</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">OK</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># BGSAVE命令，在后台进行数据备份</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">BGSAVE</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Background</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> saving</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> started</span></span></code></pre></div><ul><li>SAVE 命令会阻塞 Redis 服务器进程，直到 dump.rdb 文件创建完毕为止，在这个过程中，服务器不能处理任何的命令请求。</li><li>BGSAVE命令是非阻塞式的，在该命令执行的过程中，并不影响 Redis 服务器处理客户端的其他请求。</li></ul><blockquote><p>自动触发</p></blockquote><p>自动触发策略，是指Redis在指定的时间内，数据发生了多少次变化时，会自动执行BGSAVE命令。自动触发的条件需要配置在Redis配置文件。</p><p>redis.windows.conf配置文件</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>save 900 1     #表示900秒内如果超过1个key被修改，则执行BGSAVE命令</span></span>
<span class="line"><span>save 300 10    #表示300秒内容如超过10个key被修改，则执行BGSAVE命令</span></span></code></pre></div><blockquote><p>数据还原</p></blockquote><ol><li>先通过save或bgsave命令将当前数据库进行备份。</li><li>然后把dump.rdb 移动到其它地方</li><li>需要数据还原的时候 把dump.rdb放到redis安装目录下</li><li>重新启动redis 即可</li></ol><h4 id="rdb持久化的优缺点" tabindex="-1">RDB持久化的优缺点 <a class="header-anchor" href="#rdb持久化的优缺点" aria-label="Permalink to &quot;RDB持久化的优缺点&quot;">​</a></h4><ol><li>优点：适合于大规模的数据恢复，并且还原速度快。</li><li>缺点：快照是定期生成的，并且一次快照时间较长。所以在Redis崩溃时或多或少会丢失一部分数据。</li><li>缺点：不能过于频繁地创建 rdb 文件，否则会严重影响服务器的性能。</li></ol><h4 id="bgsave命令为什么是非阻塞式的" tabindex="-1">bgSave命令为什么是非阻塞式的？ <a class="header-anchor" href="#bgsave命令为什么是非阻塞式的" aria-label="Permalink to &quot;bgSave命令为什么是非阻塞式的？&quot;">​</a></h4><p>bgsave命令开始运行的时候，首先会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入到RDB文件中。</p><p>bgsave命令的流程</p><ul><li>首先fork主进程得到一个子进程，共享内存空间</li><li>子进程读取内存数据并写入新的RDB文件</li><li>用新RDB文件替换旧的RDB文件</li></ul><p><img src="`+n+'" alt="redis20221012170247.png"></p><h3 id="aof追加模式持久化" tabindex="-1">AOF追加模式持久化 <a class="header-anchor" href="#aof追加模式持久化" aria-label="Permalink to &quot;AOF追加模式持久化&quot;">​</a></h3><p>AOF全称为Append Only File（追加文件）,被称为追加模式，是 Redis 提供的另一种持久化策略。它能够存储 Redis 服务器已经执行过的的命令，并且只记录对内存有过修改的命令，这种数据记录方法，被叫做“增量复制”，其默认存储文件为appendonly.aof。</p><p>在Redis重启时，会把appendonly.aof文件中记录的所有写操作顺序执行一遍，确保数据恢复到最新。</p><p><img src="'+l+`" alt="redis20221014104144.png"></p><h4 id="开启aof持久化" tabindex="-1">开启AOF持久化 <a class="header-anchor" href="#开启aof持久化" aria-label="Permalink to &quot;开启AOF持久化&quot;">​</a></h4><p>AOF 机制默认处于未开启状态，可以通过修改 Redis 配置文件开启 AOF。</p><blockquote><p>Windows系统下</p></blockquote><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 先找到redis的配置文件</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#修改配置文件，把no改为 yes</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendonly</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> yes</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#确定存储文件名是否正确</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendfilename</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;appendonly.aof&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#重启服务器</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">redis-server</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --service-stop</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">redis-server</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --service-start</span></span></code></pre></div><blockquote><p>linux系统下</p></blockquote><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#修改配置文件：</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vim</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /etc/redis/redis.conf</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendonly</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> yes</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> # 把 no 改为 yes</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#确定存储文件名是否正确</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendfilename</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;appendonly.aof&quot;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#重启服务：</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /etc/init.d/redis-server</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> restart</span></span></code></pre></div><h4 id="aof持久化机制" tabindex="-1">AOF持久化机制 <a class="header-anchor" href="#aof持久化机制" aria-label="Permalink to &quot;AOF持久化机制&quot;">​</a></h4><p>AOF持久化机制：每当有一个修改数据库的命令被执行时，服务器就将命令写入到 appendonly.aof 文件中，该文件存储了服务器执行过的所有修改命令，因此当服务器重新执行一次 .aof 文件，就可以实现还原数据的目的。</p><h4 id="aof持久化策略" tabindex="-1">AOF持久化策略 <a class="header-anchor" href="#aof持久化策略" aria-label="Permalink to &quot;AOF持久化策略&quot;">​</a></h4><p>AOF持久化策略有如下几种。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 先开启用aof持久化方式</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendonly</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> yes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">           </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 默认推荐</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendfsync</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> everysec</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 表示每执行一次写命令，立即记录到AOF文件</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendfsync</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> always</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">appendfsync</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> no</span></span></code></pre></div><ul><li>Always：服务器每写入一个命令，就调用一次 fsync 函数，将缓冲区里面的命令写入到硬盘。这种模式下，服务器出现故障，也不会丢失任何已经成功执行的命令数据，但是其执行速度较慢；</li><li>Everysec（默认）：服务器每一秒调用一次 fsync 函数，将缓冲区里面的命令写入到硬盘。这种模式下，服务器出现故障，最多只丢失一秒钟内的执行的命令数据，通常都使用它作为 AOF 配置策略；</li><li>No：服务器不主动调用 fsync 函数，由操作系统决定何时将缓冲区里面的命令写入到硬盘。这种模式下，服务器遭遇意外停机时，丢失命令的数量是不确定的，所以这种策略，不确定性较大，不安全。</li></ul><p>三种策略对比 <img src="`+p+'" alt="redis20221014104417.png"></p><h4 id="aof持久化优缺点" tabindex="-1">AOF持久化优缺点 <a class="header-anchor" href="#aof持久化优缺点" aria-label="Permalink to &quot;AOF持久化优缺点&quot;">​</a></h4><ol><li>优点：AOF文件在发生断电等问题时也不会损坏，即使出现了某条日志只写入了一半的情况，也可以使用redis-check-aof工具轻松修复。</li><li>优点：AOF文件易读，可修改，在进行了某些错误的数据清除操作后，只要AOF文件没有rewrite，就可以把AOF文件备份出来，把错误的命令删除，然后恢复数据。</li><li>缺点：AOF文件通常比RDB文件更大</li><li>缺点：性能消耗比RDB高</li><li>缺点：数据恢复速度比RDB慢</li></ol><h4 id="aof文件重写" tabindex="-1">AOF文件重写 <a class="header-anchor" href="#aof文件重写" aria-label="Permalink to &quot;AOF文件重写&quot;">​</a></h4><p>aof文件会随着时间越变越大。当长时间下来，如果机器重启，读取aof文件会非常耗时，导致长时间Redis无法对外提供服务。因此就需要对 aof 文件进行重写。通过执行 bgrewriteaof 命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p><p><img src="'+h+`" alt="redis20221014104829.png"></p><p>如图，AOF原本有三个命令，<code>set num 123 和 set num 666</code>都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。所以重写命令后，AOF文件内容就是：<code>mset name jack num 666</code></p><blockquote><p>AOF文件重写有两种方式：手动执行和自动配置</p></blockquote><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 手动对aof文件进行重写</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">BGREWRITEAOF</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Background</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> append</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> only</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> file</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> rewriting</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> started</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 自动对aof文件进行重写，需要在redis配置文件进行配置</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># AOF文件比上次文件 增长超过多少百分比则触发重写</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">auto-aof-rewrite-percentage</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 100</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># AOF文件体积最小多大以上才触发重写 </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">auto-aof-rewrite-min-size</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 64mb</span></span></code></pre></div><p>该配置项表示：触发重写所需要的 aof 文件体积百分比，只有当 aof 文件的增量大于 100% 时才进行重写，也就是大一倍。比如，第一次重写时文件大小为 64M，那么第二次触发重写的文件体积为 128M，第三次重写为 256M，以此类推。如果将百分比值设置为 0 就表示关闭 AOF 自动重写功能。</p><h3 id="rdb与aof对比" tabindex="-1">RDB与AOF对比 <a class="header-anchor" href="#rdb与aof对比" aria-label="Permalink to &quot;RDB与AOF对比&quot;">​</a></h3><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会结合两者来使用。</p><p><img src="`+r+'" alt="redis20221014105251.png"></p><h2 id="redis主从模式" tabindex="-1">Redis主从模式 <a class="header-anchor" href="#redis主从模式" aria-label="Permalink to &quot;Redis主从模式&quot;">​</a></h2><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从模式的redis，实现读写分离。</p><p>在软件的架构中，主从模式（Master-Slave）是使用较多的一种架构。主（Master）和从（Slave）分别部署在不同的服务器上，当主节点服务器写入数据时，同时也会将数据同步至从节点服务器，通常情况下，主节点负责写入数据，而从节点负责读取数据。</p><p><img src="'+d+'" alt="redis20221014105547.png"></p><p>在主从模式中 master 主机只执行写命令，其他 salve 从机只执行读命令，这种读写分离的模式可以大大减轻 Redis 主机的数据读取压力，从而提高了Redis 的效率，并同时提供了多个数据备份。主从模式是搭建 Redis Cluster 集群最简单的一种方式。</p><blockquote><p>主从模式的3种方式</p></blockquote><p><img src="'+k+'" alt="4"><img src="'+o+'" alt="5"><img src="'+c+`" alt="6"></p><h3 id="搭建主从模式" tabindex="-1">搭建主从模式 <a class="header-anchor" href="#搭建主从模式" aria-label="Permalink to &quot;搭建主从模式&quot;">​</a></h3><p>安装3个redis，用来搭建主从集群，信息如下</p><table tabindex="0"><thead><tr><th style="text-align:center;">IP</th><th style="text-align:center;">PORT</th><th style="text-align:center;">角色</th></tr></thead><tbody><tr><td style="text-align:center;">192.168.150.101</td><td style="text-align:center;">6379</td><td style="text-align:center;">master</td></tr><tr><td style="text-align:center;">192.168.150.101</td><td style="text-align:center;">6380</td><td style="text-align:center;">slave</td></tr><tr><td style="text-align:center;">192.168.150.101</td><td style="text-align:center;">6381</td><td style="text-align:center;">slave</td></tr></tbody></table><p>将redis的安装包复制成3份，一份作为主机redis的，其余两份作为从机redis的。</p><blockquote><p>1 主机redis配置</p></blockquote><p>无需特殊配置。默认为6379端口。</p><blockquote><p>2 从机redis配置</p></blockquote><p>修改从机的redis.conf配置文件</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 这是6380从机的配置文件更改</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 开启后台运行</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">daemonize</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> yes</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 修改端口</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">port</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 6380</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 指定主机ip端口</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">slaveof</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 192.168.150.101</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 6379</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 这是6381从机的配置文件更改</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 开启后台运行</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">daemonize</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> yes</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 修改端口</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">port</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 6381</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 指定主机ip端口</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">slaveof</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 192.168.150.101</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 6379</span></span></code></pre></div><blockquote><p>3 启动主机从机</p></blockquote><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 启动主机从机的redis</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># windows中的启动命令如下</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">redis-server</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --service-start</span></span></code></pre></div><p>主从模式建立后，从机默认为只读配置，如果修改从节点的只读配置，会导致主从数据不一致。</p><blockquote><p>4 查看redis的的主从信息。</p></blockquote><p><code>info replication</code>可以查询当前reids是主机还是从机</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 主机查看信息</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6379</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">info</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> replication</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Replication</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">role:master</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#从机6380查看信息</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6380</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">info</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> replication</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Replication</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">role:slave</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">...</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#从机6381查看信息</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">127.0.0.1:6381</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">info</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> replication</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Replication</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">role:slave</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">...</span></span></code></pre></div><h3 id="主从模式的不足" tabindex="-1">主从模式的不足 <a class="header-anchor" href="#主从模式的不足" aria-label="Permalink to &quot;主从模式的不足&quot;">​</a></h3><ol><li>Redis主从模式不具备自动容错和恢复功能，如果主节点宕机，Redis 集群将无法工作，此时需要人为干预，将从节点提升为主节点。</li><li>如果主机宕机前有一部分数据未能及时同步到从机，即使切换主机后也会造成数据不一致的问题，从而降低了系统的可用性。</li><li>因为只有一个主节点，所以其写入能力和存储能力都受到一定程度地限制。</li><li>在进行主从机的数据全量同步时，若同步的数据量较大可能会造卡顿的现象。</li></ol><h3 id="主从模式的数据同步" tabindex="-1">主从模式的数据同步 <a class="header-anchor" href="#主从模式的数据同步" aria-label="Permalink to &quot;主从模式的数据同步&quot;">​</a></h3><p>主从第一次建立连接时，会执行全量同步，将主机的所有数据都拷贝给从机。在其余时间，主从之间都是进行增量同步。</p><h4 id="全量同步" tabindex="-1">全量同步 <a class="header-anchor" href="#全量同步" aria-label="Permalink to &quot;全量同步&quot;">​</a></h4><p>全量同步的流程如图所示 <img src="`+g+'" alt="redis20221014155055.png"></p><blockquote><p>master如何得知salve是第一次来连接呢?</p></blockquote><ul><li>Replication Id：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid</li><li>offset：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录master的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。</li></ul><ol><li>如果slave要进行数据同步，必须向master声明自己的replid和offset，master才可以判断到底需要同步哪些数据。</li><li>因为slave原本也是一个master，有自己的replid和offset，当第一次变成slave时，发送的replid和offset是自己的replid和offset。</li><li>master判断发现slave发送来的replid与自己的不一致，说明这是一个全新的slave，就知道要做全量同步了。</li><li>master会将自己的replid和offset都发送给这个slave，slave保存这些信息。以后slave的replid就与master的replid就一致了。</li></ol><p>因此，master判断一个节点是否是第一次同步的依据，就是看主机和从机的replid和offset是否一致。</p><h4 id="增量同步" tabindex="-1">增量同步 <a class="header-anchor" href="#增量同步" aria-label="Permalink to &quot;增量同步&quot;">​</a></h4><p>除了主机从机第一次连接时做全量同步，其它大多数时候slave与master都是增量同步。</p><p>增量同步：就是只更新slave与master存在差异的部分数据。</p><p>增量同步的流程如图所示 <img src="'+F+'" alt="redis20221014155319.png"></p><blockquote><p>master怎么知道slave与自己的数据差异?</p></blockquote><p>主要是通过repl_baklog文件来判断数据差异。</p><p>repl_baklog文件是一个固定大小的数组，只不过数组是环形，也就是到达数组末尾后，会再次从0开始读写，这样数组头部的数据就会被覆盖。</p><p>repl_baklog文件中会记录Redis处理过的命令日志及offset，包括master当前的offset，和slave已经拷贝到的offset。</p><blockquote><p>判断数据差异的流程</p></blockquote><ol><li>slave与master的offset之间的差异，就是salve需要增量拷贝的数据了。 <img src="'+y+'" alt="redis20221014155420.png"></li><li>随着不断有数据写入，master的offset逐渐变大，slave也不断的拷贝，追赶master的offset，直到数组被填满。 <img src="'+b+'" alt="redis20221014155500.png"><img src="'+u+'" alt="redis20221014155540.png"></li><li>此时如果有新的数据写入，就会覆盖数组中的旧数据。不过，旧的数据只要是绿色的，说明是已经被同步到slave的数据，即便被覆盖了也没什么影响。因为未同步的仅仅是红色部分。</li><li>当slave出现网络阻塞，导致master的offset远远超过了slave的offset。如果master继续写入新数据，其offset就会覆盖旧的数据，直到将slave现在的offset也覆盖。 <img src="'+m+'" alt="redis20221014155712.png"></li></ol><p>棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果slave恢复，需要同步，却发现自己的offset都没有了，无法完成增量同步了。只能做全量同步。</p><h2 id="redis哨兵模式" tabindex="-1">Redis哨兵模式 <a class="header-anchor" href="#redis哨兵模式" aria-label="Permalink to &quot;Redis哨兵模式&quot;">​</a></h2><p>在 Redis 主从复制模式中，因为系统不具备自动恢复的功能，所以当主服务器（master）宕机后，需要手动把一台从服务器（slave）切换为主服务器。在这个过程中，不仅需要人为干预，而且还会造成一段时间内服务器处于不可用状态，同时数据安全性也得不到保障，因此主从模式的可用性较低，不适用于线上生产环境。</p><p>Redis 官方推荐一种高可用方案，也就是 Redis Sentinel 哨兵模式，它弥补了主从模式的不足。保证了系统的高可用性。</p><ul><li>在哨兵模式中，Redis客户端会首先连接 Sentinel，通过 Sentinel 来查询主节点的地址，然后再去连接主节点进行数据交互。</li><li>在哨兵模式中，Sentinel 负责监控主从节点的状态。当主节点挂掉时，自动选择一个最优的从节点切换为主节点。</li><li>在哨兵模式中，当主节点发生故障后，Redis客户端会重新向 Sentinel 要主节点的地址，Sentinel 会将最新的主节点地址告诉客户端。因此应用程序无需重启即可自动完成主从节点切换。</li></ul><blockquote><p>哨兵模式结构图</p></blockquote><p><img src="'+C+'" alt="redis_20230727105444.png"><img src="'+B+'" alt="redis20221014161423.png"></p><blockquote><p>多哨兵模式结构图</p></blockquote><p>在实际生产情况中，为避免 Sentinel 发生意外，它一般是由 3～5 个节点组成，这样就算挂了个别节点，该 Sentinel 集群仍然可以正常运转。</p><p><img src="'+A+'" alt="redis_20230727110028.png"></p><h3 id="哨兵的作用" tabindex="-1">哨兵的作用 <a class="header-anchor" href="#哨兵的作用" aria-label="Permalink to &quot;哨兵的作用&quot;">​</a></h3><p>哨兵的作用如下</p><ul><li>监控：哨兵节点会以每秒一次的频率对每个 Redis 节点发送PING命令，并通过 Redis 节点的回复来判断其运行状态。</li><li>自动故障恢复：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主节点。</li><li>通知：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端</li></ul><h4 id="哨兵监控redis节点" tabindex="-1">哨兵监控redis节点 <a class="header-anchor" href="#哨兵监控redis节点" aria-label="Permalink to &quot;哨兵监控redis节点&quot;">​</a></h4><p>哨兵节点会以每秒一次的频率对每个 Redis 节点发送PING命令，并通过 Redis 节点的回复来判断其运行状态。</p><p>判断分为2种情况：</p><ol><li>主观下线：如果哨兵发现某个redis节点未在规定时间响应，则认为该redis节点主观下线。</li><li>客观下线：如果超过半数以上的哨兵都认为该redis节点主观下线，则该redis节点客观下线。</li></ol><h4 id="哨兵自动故障恢复redis节点" tabindex="-1">哨兵自动故障恢复redis节点 <a class="header-anchor" href="#哨兵自动故障恢复redis节点" aria-label="Permalink to &quot;哨兵自动故障恢复redis节点&quot;">​</a></h4><p>Sentinel哨兵监控主从节点的状态。当主节点挂掉时，自动选择一个最优的从节点切换为主节点。</p><blockquote><p>哨兵如何切换主从节点，流程如下</p></blockquote><ol><li>sentinel给选中的slave节点发送slaveof no one命令，让该节点成为master节点。</li><li>sentinel给所有其它slave节点发送 slaveof 命令，指定新master节点的地址端口。让这些slave节点成为新master节点的从节点，开始从新的master节点上同步数据。</li><li>最后，sentinel将故障节点标记为slave节点，当故障节点恢复后会自动成为新的master的slave节点</li></ol><p><img src="'+v+`" alt="redis20221014161617.png"></p><h3 id="搭建哨兵" tabindex="-1">搭建哨兵 <a class="header-anchor" href="#搭建哨兵" aria-label="Permalink to &quot;搭建哨兵&quot;">​</a></h3><ol><li>搭建哨兵模式，需要先搭建主从模式。</li></ol><p>例如,6379端口的redis为主节点。6380，6381端口的redis为从节点。</p><ol start="2"><li>安装sentinel</li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sudo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> apt</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> redis-sentinel</span></span></code></pre></div><ol start="3"><li>修改sentinel配置文件sentinel.conf</li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 默认端口，可修改</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">port</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 26379</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Sentinel</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> monitor</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> ABC</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 127.0.0.1</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 6379</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span></code></pre></div><p>第二个配置项表示，让 sentinel 去监控一个地址为 ip:port 的主服务器，master-name 可以自定义；quorum是一个数字，表示当有多少个 sentinel 认为主服务器宕机时，它才算真正的宕机掉。</p><ol start="4"><li>启动sentinel哨兵</li></ol><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 方式一</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">redis-sentinel</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sentinel.conf</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 方式二 </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">redis-server</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> sentinel.conf</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --sentinel</span></span></code></pre></div><ol start="5"><li>sentinel配置文件其他配置项</li></ol><p><img src="`+f+'" alt="redis_20230727134103.png"></p><h2 id="redis分片集群模式" tabindex="-1">Redis分片集群模式 <a class="header-anchor" href="#redis分片集群模式" aria-label="Permalink to &quot;Redis分片集群模式&quot;">​</a></h2><p>主从模式和哨兵模式可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：海量数据存储问题和高并发写的问题。</p><p>使用分片集群模式可以解决上述两个问题，如图所示 <img src="'+D+'" alt="redis20221014163639.png"></p><blockquote><p>分片集群的特征</p></blockquote><ul><li>分片集群模式中有多个master，每个master保存不同数据</li><li>每个master都可以有多个slave节点</li><li>master与master之间通过ping监测彼此健康状态</li><li>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</li></ul><h3 id="搭建分片集群" tabindex="-1">搭建分片集群 <a class="header-anchor" href="#搭建分片集群" aria-label="Permalink to &quot;搭建分片集群&quot;">​</a></h3><p>分片集群需要的节点数量较多，这里搭建一个最小的分片集群，包含3个master节点，每个master包含一个slave节点，结构如下</p><p><img src="'+q+`" alt="redis20221014152738.png"></p><p>这里会在同一台虚拟机中开启6个redis实例，模拟分片集群，信息如下</p><table tabindex="0"><thead><tr><th style="text-align:center;">IP</th><th style="text-align:center;">PORT</th><th style="text-align:center;">角色</th></tr></thead><tbody><tr><td style="text-align:center;">192.168.150.101</td><td style="text-align:center;">7001</td><td style="text-align:center;">master</td></tr><tr><td style="text-align:center;">192.168.150.102</td><td style="text-align:center;">7002</td><td style="text-align:center;">master</td></tr><tr><td style="text-align:center;">192.168.150.103</td><td style="text-align:center;">7003</td><td style="text-align:center;">master</td></tr><tr><td style="text-align:center;">192.168.150.104</td><td style="text-align:center;">8001</td><td style="text-align:center;">slave</td></tr><tr><td style="text-align:center;">192.168.150.105</td><td style="text-align:center;">8002</td><td style="text-align:center;">slave</td></tr><tr><td style="text-align:center;">192.168.150.106</td><td style="text-align:center;">8003</td><td style="text-align:center;">slave</td></tr></tbody></table><blockquote><p>准备实例和配置</p></blockquote><p>将redis安装目录复制为6份。每一份作为一个redis实例。修改配置如下。</p><p>除了端口不同，其他配置相同</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 监听端口</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">port</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 7001</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 开启集群功能</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cluster-enabled</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> yes</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 节点心跳失败的超时时间</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">cluster-node-timeout</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5000</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 让redis后台运行</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">daemonize</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> yes</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 数据库数量</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">databases</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span></code></pre></div><blockquote><p>启动6个redis实例</p></blockquote><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 启动redis</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># windows中的启动命令如下</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">redis-server</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --service-start</span></span></code></pre></div><blockquote><p>创建集群</p></blockquote><p>虽然6个redis服务启动了，但是目前每个redis服务之间都是独立的，没有任何关联。我们需要执行命令来创建集群，集群管理命令目前都集成到redis-cli中。</p><p>集群管理命令，格式如下：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">redis-cli</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --cluster</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> create</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --cluster-replicas</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 192.168.150.101:7001</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 192.168.150.101:7002</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 192.168.150.101:7003</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 192.168.150.101:8001</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 192.168.150.101:8002</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 192.168.150.101:8003</span></span></code></pre></div><p>说明：</p><ul><li><code>redis-cli --cluster</code>：代表集群操作命令</li><li><code>create</code>：代表是创建集群</li><li><code>--cluster-replicas 1</code> ：指定集群中每个master的副本个数为1，此时<code>节点总数 ÷ (replicas + 1)</code> 得到的就是master的数量。因此节点列表中的前n个就是master，其它节点都是slave节点，随机分配到不同master</li></ul><p>集群管理命令运行后的样子 <img src="`+_+'" alt="redis20221014152945.png"> 这里输入yes，则集群开始创建 <img src="'+E+'" alt="redis20221014153037.png"> 通过命令可以查看集群状态 <img src="'+R+'" alt="redis20221014153134.png"></p><blockquote><p>测试</p></blockquote><p>集群操作时，需要给<code>redis-cli</code>加上<code>-c</code>参数才可以。</p><p>如图连接7001节点，存储一个数据，然后在7003节点查询出数据。 <img src="'+x+'" alt="redis20221014153258.png"></p>',159)]))}const N=i(O,[["render",P]]);export{M as __pageData,N as default};
