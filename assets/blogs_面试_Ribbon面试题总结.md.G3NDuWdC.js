import{_ as o,c as b,o as l,ak as a}from"./chunks/framework.CmzJUe0_.js";const c=JSON.parse('{"title":"Ribbon面试题总结","description":"","frontmatter":{"title":"Ribbon面试题总结","date":"2023-12-05T00:00:00.000Z","sidebar":"auto","categories":["面试"],"tags":["Ribbon"]},"headers":[],"relativePath":"blogs/面试/Ribbon面试题总结.md","filePath":"blogs/面试/Ribbon面试题总结.md"}'),e={name:"blogs/面试/Ribbon面试题总结.md"};function n(r,i,t,R,s,d){return l(),b("div",null,i[0]||(i[0]=[a('<p>[toc]</p><h1 id="ribbon面试题总结" tabindex="-1">Ribbon面试题总结 <a class="header-anchor" href="#ribbon面试题总结" aria-label="Permalink to &quot;Ribbon面试题总结&quot;">​</a></h1><h2 id="ribbon的实现原理是什么" tabindex="-1">Ribbon的实现原理是什么？ <a class="header-anchor" href="#ribbon的实现原理是什么" aria-label="Permalink to &quot;Ribbon的实现原理是什么？&quot;">​</a></h2><ol><li>通过拦截器将被注解@LoadBalanced修改的请求进行拦截。</li><li>将请求中的服务名信息，会根据注册中心的注册表，解析成具体的ip地址。如果服务名对于多个ip地址，那么ribbon在选择地址的时候，会进行负载均衡。</li><li>当确定好ip地址的时候，ribbon会放行请求。</li></ol><h2 id="ribbon是如何实现负载均衡" tabindex="-1">Ribbon是如何实现负载均衡? <a class="header-anchor" href="#ribbon是如何实现负载均衡" aria-label="Permalink to &quot;Ribbon是如何实现负载均衡?&quot;">​</a></h2><p>Ribbon是客户端负载均衡。即客户端自已通过负载均衡算法，来选择服务集群中的某个服务实例来调用。</p><p>Ribbon实现负载均衡的前提：客户端需要提前知道所有的服务实例信息。</p><p>例如系统中服务A调用服务B。Ribbon实现负载均衡的过程如下：</p><ol><li>服务A发送请求，调用服务B。服务B有多个实例节点在注册中心。</li><li>请求被Ribbon拦截下来。并进行处理。</li><li>Ribbon先获取到在注册中心中服务B的所有服务实例信息。</li><li>Ribbon根据负载均衡算法，选择服务B的其中一个实例。</li><li>最后Ribbon将请求发送到服务B实例上。</li><li>至此，Ribbon完成了服务A调用服务B的负载均衡。</li></ol><h2 id="ribbon支持的负载均衡策略有哪些" tabindex="-1">Ribbon支持的负载均衡策略有哪些? <a class="header-anchor" href="#ribbon支持的负载均衡策略有哪些" aria-label="Permalink to &quot;Ribbon支持的负载均衡策略有哪些?&quot;">​</a></h2><p>Ribbon支持的负载均衡策略如下：</p><ol><li>RoundRobinRule 轮询策略: 默认的负载均衡策略。</li><li>AvailabilityFilteringRule 可用性过滤策略：该策略根据服务的运行状态来分配权重，过滤掉连接失败或特别高并发的服务实例。</li><li>WeightedResponseTimeRule 加权响应时间策略: 它对轮询策略进行了扩展。首先根据每个服务实例的运行情况计算出权重，然后根据权重进行服务实例的挑选。</li><li>ZoneAvoidanceRule 区域感知轮询策略: 该策略以区域、可用的服务器为基础，选择服务实例并对服务实例进行分类。</li><li>BestAvailableRule 最空闲策略：选择并发请求最小的服务实例来提供服务。</li><li>RandomRule 随机策略: 随机选择一个可用的服务实例。</li><li>RetryRule 重试策略</li></ol><h2 id="如何修改ribbon的负载均衡策略" tabindex="-1">如何修改Ribbon的负载均衡策略 ? <a class="header-anchor" href="#如何修改ribbon的负载均衡策略" aria-label="Permalink to &quot;如何修改Ribbon的负载均衡策略 ?&quot;">​</a></h2><p>修改Ribbon负载均衡策略的方式有二种:</p><ol><li>如果负载均衡策略之前配置在Ribbo配置类中，那么直接在配置类中修改即可。</li><li>如果负载均衡策略之前配置在application.yml文件中，那么直接在application.yml文件中修改即可。</li></ol><h2 id="ribbon如何自定义负载均衡策略" tabindex="-1">Ribbon如何自定义负载均衡策略? <a class="header-anchor" href="#ribbon如何自定义负载均衡策略" aria-label="Permalink to &quot;Ribbon如何自定义负载均衡策略?&quot;">​</a></h2><ol><li>创建Ribbon配置类，该类实现IRule接口。</li><li>实现IRule接口的choose方法即可。至于具体的负载均衡规则如何做，要看具体的需求。</li></ol>',17)]))}const p=o(e,[["render",n]]);export{c as __pageData,p as default};
