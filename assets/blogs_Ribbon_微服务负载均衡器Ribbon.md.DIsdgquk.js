import{_ as i}from"./chunks/20220728161129.9vGko5Qv.js";import{_ as a,c as n,o as l,ak as p}from"./chunks/framework.CmzJUe0_.js";const e="/assets/ribbon20220804161456.BCnjZKdx.png",t="/assets/ribbon20220804162054.DXic_MnU.png",o="/assets/ribbon20220804164526.Jsg1p9wm.png",_=JSON.parse('{"title":"微服务负载均衡器Ribbon 版本2.3.0","description":"","frontmatter":{"title":"微服务负载均衡器Ribbon 版本2.3.0","date":"2022-08-04T00:00:00.000Z","sidebar":"auto","categories":["后端"],"tags":["Ribbon"]},"headers":[],"relativePath":"blogs/Ribbon/微服务负载均衡器Ribbon.md","filePath":"blogs/Ribbon/微服务负载均衡器Ribbon.md"}'),r={name:"blogs/Ribbon/微服务负载均衡器Ribbon.md"};function h(b,s,k,d,c,g){return l(),n("div",null,s[0]||(s[0]=[p('<p>[toc]</p><h1 id="微服务负载均衡器ribbon" tabindex="-1">微服务负载均衡器Ribbon <a class="header-anchor" href="#微服务负载均衡器ribbon" aria-label="Permalink to &quot;微服务负载均衡器Ribbon&quot;">​</a></h1><p>当前使用Ribbon版本为2.3.0。</p><p>下图为微服务架构图 <img src="'+i+'" alt="20220728161129.png"></p><p>目前主流有两种负载均衡方案：</p><ul><li>集中式负载均衡：在客户端和服务端中间使用独立的代理方式进行负载，有硬件的（比如 F5），也有软件的（比如Nginx）。</li><li>客户端负载均衡：即在客户端就进行负载均衡算法来选择服务端。Ribbon就属于客户端负载均衡。</li></ul><p>SpringCloud Ribbon是基于Netflix Ribbon 实现的一套客户端的负载均衡工具。Ribbon先获取到提供的所有服务实例，之后Ribbon会自动基于某种规则(轮询，随机)去调用这些服务。</p><blockquote><p>什么是客户端负载均衡？ 客户端会有一个服务器地址列表，在发送请求前通过负载均衡算法选择一个服务器，然后进行访问。即在客户端就进行负载均衡算法分配。</p></blockquote><p><img src="'+e+'" alt="ribbon20220804161456.png"></p><blockquote><p>什么是集中式负载均衡？ 例如通过Nginx进行负载均衡，先发送请求，然后通过负载均衡算法，在多个服务器之间选择一个进行访问；即在服务器端再进行负载均衡算法分配。</p></blockquote><p><img src="'+t+'" alt="ribbon20220804162054.png"></p><h2 id="_1-常见的负载均衡算法" tabindex="-1">1.常见的负载均衡算法 <a class="header-anchor" href="#_1-常见的负载均衡算法" aria-label="Permalink to &quot;1.常见的负载均衡算法&quot;">​</a></h2><ul><li>随机：通过随机选择服务进行执行，一般这种方式使用较少;</li><li>轮询：负载均衡默认实现方式，请求进来之后排队处理;</li><li>加权轮询：通过对服务器性能的分型，给高配置，低负载的服务器分配更高的权重，均衡各个服务器的压力;</li><li>最小链接数：根据服务器的情况，比如请求积压数等参数，将请求分配到当前压力最小的服务器上。</li></ul><h2 id="_2-spring-cloud-alibaba-引入ribbon" tabindex="-1">2.Spring Cloud Alibaba 引入ribbon <a class="header-anchor" href="#_2-spring-cloud-alibaba-引入ribbon" aria-label="Permalink to &quot;2.Spring Cloud Alibaba 引入ribbon&quot;">​</a></h2><p><span style="color:red;">ribbon的负载均衡方案主要是客户端负载均衡，即当客户端调用多个同名服务端集群时，可以通过ribbon来负载均衡。</span></p><p>① 引入ribbon:Nacos2.2.8版本内置了ribbon。当引入nacos依赖时，可不引入ribbon依赖。</p><p><img src="'+o+`" alt="ribbon20220804164526.png"></p><p>②：修改服务调用者的配置文件，注意这个配置idea没有提示。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># 针对某个这个服务提供者，ribbon使用的负载策略</span></span>
<span class="line"><span># user-service是注册中心中某个服务提供者的服务名</span></span>
<span class="line"><span># com.alibaba.cloud.nacos.ribbon.NacosRule 这个是基于权重&amp;随机的负载策略算法</span></span>
<span class="line"><span>user-service.ribbon.NFLoadBalancerRuleClassName=com.alibaba.cloud.nacos.ribbon.NacosRule</span></span></code></pre></div><p>③：运行服务，之后多次调用服务提供者user-service的某个接口，观察端口的变化。可以看出负载均衡生效。</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//order和order2两个服务都在注册中心的注册名为user-service</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//这两个服务的都有下面的接口。区别是各自占用的端口不同。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RestController</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">@</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RequestMapping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/order&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> orderController</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;\${server.port}&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    private</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String port;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    @</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">RequestMapping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/get&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getOrder</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;order &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">port;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="_3-loadbalancer和ribbon的区别" tabindex="-1">3.LoadBalancer和Ribbon的区别？ <a class="header-anchor" href="#_3-loadbalancer和ribbon的区别" aria-label="Permalink to &quot;3.LoadBalancer和Ribbon的区别？&quot;">​</a></h2><p>Spring Cloud LoadBalancer是Spring Cloud官方自己提供的客户端负载均衡器，用来替代已经闭源的Ribbon。</p><p>目前由于LoadBalancer只支持轮询的负载均衡策略，没有Ribbon强大，所以暂时不建议用LoadBalancer去替换Ribbon。</p>`,24)]))}const y=a(r,[["render",h]]);export{_ as __pageData,y as default};
