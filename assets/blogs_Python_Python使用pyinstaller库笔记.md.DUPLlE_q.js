import{_ as i,c as a,o as n,ak as p}from"./chunks/framework.CmzJUe0_.js";const l="/assets/python_20240528152503.HIlVTwZP.png",t="/assets/python_20240528152725.DYSjfut9.png",e="/assets/python_20240528154932.Dycv5vE2.png",h="/assets/python_20240528170031.B7X4olsF.png",F=JSON.parse('{"title":"Python使用pyinstaller库笔记","description":"","frontmatter":{"title":"Python使用pyinstaller库笔记","date":"2024-05-28T00:00:00.000Z","sidebar":"auto","categories":["Python"],"tags":["Python"]},"headers":[],"relativePath":"blogs/Python/Python使用pyinstaller库笔记.md","filePath":"blogs/Python/Python使用pyinstaller库笔记.md"}'),k={name:"blogs/Python/Python使用pyinstaller库笔记.md"};function r(o,s,d,y,c,g){return n(),a("div",null,s[0]||(s[0]=[p(`<p>[toc]</p><h1 id="python使用pyinstaller库笔记" tabindex="-1">Python使用pyinstaller库笔记 <a class="header-anchor" href="#python使用pyinstaller库笔记" aria-label="Permalink to &quot;Python使用pyinstaller库笔记&quot;">​</a></h1><p><a href="https://pyinstaller.org/" target="_blank" rel="noreferrer">pyinstaller官网：https://pyinstaller.org/</a></p><p>pyinstaller 是一个第三方库，专用于python程序的exe打包。 pyinstaller可以将普通的*.py程序文件编译（打包）成exe应用。</p><p>exe文件是可执行文件，打包后的*.exe 应用可以不用依赖python环境，直接在他人的电脑上运行。</p><p>python有多种方法用于将普通的*.py程序文件编译（打包）成exe应用。其中pyinstaller打包最强大而且好用。</p><h2 id="安装" tabindex="-1">安装 <a class="header-anchor" href="#安装" aria-label="Permalink to &quot;安装&quot;">​</a></h2><p>使用 pip 安装 pyinstaller 即可。</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pip</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pyinstaller</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 查看版本</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pyinstaller</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --version</span></span></code></pre></div><h2 id="编译打包原理介绍" tabindex="-1">编译打包原理介绍 <a class="header-anchor" href="#编译打包原理介绍" aria-label="Permalink to &quot;编译打包原理介绍&quot;">​</a></h2><p>pyinstaller编译打包的大致过程是</p><ol><li>pyinstaller先读取你需要打包的python文件，然后搜索这个python文件中使用的模块。</li><li>然后将所需的模块以及Python解释器放到一起，并通过一些操作构建exe，最终形成你的应用程序。</li></ol><h3 id="pyinstaller如何搜索模块" tabindex="-1">pyinstaller如何搜索模块? <a class="header-anchor" href="#pyinstaller如何搜索模块" aria-label="Permalink to &quot;pyinstaller如何搜索模块?&quot;">​</a></h3><p>pyinstaller会读取文件中的import语句，然后根据import语句来找到对应的模块。</p><p>如果文件中使用了一些特殊的导入方式，比如使用__import__()函数，使用importlib里面的导入函数。那么pyinstaller很可能找不到对应的模块。</p><h3 id="pyinstaller编译打包的两种方式" tabindex="-1">pyinstaller编译打包的两种方式 <a class="header-anchor" href="#pyinstaller编译打包的两种方式" aria-label="Permalink to &quot;pyinstaller编译打包的两种方式&quot;">​</a></h3><p>pyinstaller编译打包的方式有两种，一种是打包后形成一个单个文件夹。另一种是打包后会形成一个单个 *.exe 应用文件。</p><blockquote><p>打包成单个文件夹</p></blockquote><p>pyinstaller编译打包后会产生一个文件夹。文件夹中包含一个exe文件，以及其他一些依赖文件（比如一些dll文件，图片等）。后面你只要把该文件夹发给别人运行即可。</p><p>当你运行文件夹里面的exe文件后，pyinstaller其实是启动了解释器，然后通过解释器运行你的python程序。</p><p>优点：</p><ol><li>便于调试，因为可以看到pyinstaller将哪些模块文件放到了文件夹中。</li><li>便于更新，当前要更新程序的时候，可以只替换文件夹中对应的部分即可。</li></ol><p>缺点：</p><ol><li>打包产生的文件夹，体积相比打包产生的exe文件，体积更大。因为文件夹中的文件都是没有压缩的。</li></ol><blockquote><p>打包成单个exe文件</p></blockquote><p>pyinstaller编译打包后会产生单个exe文件。所有的依赖文件都会被压缩到exe文件中。</p><p>优点：</p><ol><li>在经过压缩后，这个exe文件的文件会大大减小。</li></ol><p>缺点：</p><ol><li>单个exe文件的启动速度比较慢</li></ol><h3 id="pyinstaller编译打包后的运行效果" tabindex="-1">pyinstaller编译打包后的运行效果 <a class="header-anchor" href="#pyinstaller编译打包后的运行效果" aria-label="Permalink to &quot;pyinstaller编译打包后的运行效果&quot;">​</a></h3><p>例如你要打包 first.py 程序文件，那么pyinstaller编译打包后会产生一个 first.exe 文件，双击运行exe程序文件。</p><p>默认情况下，运行这个exe程序文件会开启一个黑色的控制台（即cmd）。</p><p>这个控制台用于为python提供标准输入(stdin)，标准输出(stdout)，标准错误(stderr)。也就是说，这个控制台会显示程序中的 print函数的输出信息，input函数的输入信息，还会输出python的异常信息。</p><p>python文件有一种后缀名*.pyw，这样的程序在经过编译打包后，产生的exe文件。执行这个exe文件默认会隐藏控制台。如果将文件后缀命名为pyw，那么pyinstaller也会认为它默认隐藏控制台。</p><h2 id="编译打包" tabindex="-1">编译打包 <a class="header-anchor" href="#编译打包" aria-label="Permalink to &quot;编译打包&quot;">​</a></h2><blockquote><p>编译打包步骤</p></blockquote><ol><li>先进入到主程序文件的目录中。</li><li>输入上面的命令，对程序进行编译打包。</li><li>pyinstaller会生成一个spec文件将一些打包参数放到里面，然后进行打包。</li><li>打包完成后，会在目录下创建一个dist文件夹，里面存储了打包后的结果。还会创建一个build文件夹并写入一些日志信息。</li></ol><blockquote><p>基本语法</p></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span># test1.py 就是你要打包的主程序文件</span></span>
<span class="line"><span>pyinstaller test1.py</span></span></code></pre></div><p>运行结果如图所示。如果没有错误消息，那么编译打包就成功了。</p><p><img src="`+l+'" alt="python_20240528152503.png"><img src="'+t+`" alt="python_20240528152725.png"></p><p>打包后，会在当前目录下创建了build和dist文件夹，以及一个spec文件。</p><ul><li>dist文件夹包含打包结果文件，即exe文件和依赖文件。</li><li>build文件夹中是一些打包过程中产生的日志信息</li><li>spec文件里面是用于打包的配置信息。</li></ul><blockquote><p>pyinstaller 命令可选参数</p></blockquote><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># （默认） 文件夹模式。在打包完成后生成一个文件夹，其中包含exe文件和依赖文件。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">-D</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 单文件模式。在打包完成后只会生成一个单独的exe文件。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">-F</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 这三个参数都是相同的作用。（默认）打包程序运行后出现一个黑色的控制台窗口</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">-c</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">--console</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">--nowindowed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 这三个参数也都是相同的作用。打包程序运行后隐藏控制台窗口</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">-w</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">--windowed</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">--noconsole</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">   </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 设置打包后的exe程序的图标（只能在Windows和macOS上使用）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">-i</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;icon.ico&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">--icon</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;icon.ico&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#  添加一个启动画面（图片文件）路径，在程序运行前显示指定的启动图片，起到加载提示的效果。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">--splash</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> img_file_path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 指定一个文件夹或文件（非二进制），将其嵌入到exe中。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">--add-data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">SRC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DEST</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> or</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> SRC:DES</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 和--add-data类似，不过指定的文件夹或文件是二进制的</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">--add-binary</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">SRC</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DEST</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> or</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> SRC:DES</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 提供一个路径进行搜索并且导入里面的模块</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 这可以解决有时候第三方模块找不到的问题。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">-p</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> DIR</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">--paths</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> DIR</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 当pyinstaller在程序中找不到一些模块时，需要你额外指定。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 这个参数可以多次使用，可以解决一些模块找不到的问题。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">--hidden-import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> MODULENAME</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">--hiddenimport</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> MODULENAME</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 禁用异常提示（只能在Windows和macOS上使用）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">--disable-windowed-traceback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 打印pyinstaller的帮助信息</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">--help</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">-h</span></span></code></pre></div><p>例子</p><div class="language-py vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 编译打包first.py程序，编译打包为单exe文件，隐藏控制台，设置exe图标为icon.ico</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">pyinstaller </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">F </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">w </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">i </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;icon.ico&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> first.py</span></span></code></pre></div><h3 id="更改图标" tabindex="-1">更改图标 <a class="header-anchor" href="#更改图标" aria-label="Permalink to &quot;更改图标&quot;">​</a></h3><p>python程序文件打包成exe文件后，默认的程序图标是一个“蛇”形，但我们也可以进行更改。（该功能只能在Windows和macOS上使用）</p><p>假设程序目录结构如下</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>- my_demo1</span></span>
<span class="line"><span>    - test1.py</span></span>
<span class="line"><span>    - icon.ico</span></span></code></pre></div><p>那么更改图标的打包命令如下所示</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>pyinstaller -i icon.ico test1.py</span></span></code></pre></div><h3 id="启动画面" tabindex="-1">启动画面 <a class="header-anchor" href="#启动画面" aria-label="Permalink to &quot;启动画面&quot;">​</a></h3><p>在有些情况下，我们在双击运行程序的时候，可以需要一个启动画面（闪屏）进行过渡，提示用户正在进行加载。这个启动画面可以是单张图片。</p><p>设置启动画面，需要先准备一张图片，必须是PNG格式。然后在打包时加上--splash参数，并传入图片路径，这张图片就会作为程序的启动画面。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>pyinstaller --splash aaa.png test1.py</span></span></code></pre></div><p>另外在代码中，控制启动画面可以通过pyi_splash模块。该模块在pyinstaller打包成exe之前是不起作用的，所以必须带上try...except...代码。</p><p>在程序开头部分添加以下代码。pyi_splash.close()方法用于关闭启动画面。一般放在程序开头即可，因为只要运行到程序开头，说明exe文件的加载就基本完成了。</p><div class="language-py vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">py</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">try</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> pyi_splash</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    pyi_splash.close()</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">except</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ImportError</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    pass</span></span></code></pre></div><p>如果不用这段代码关闭启动画面，那么启动画面将一直显示。</p><h3 id="禁用异常提示" tabindex="-1">禁用异常提示 <a class="header-anchor" href="#禁用异常提示" aria-label="Permalink to &quot;禁用异常提示&quot;">​</a></h3><p><code>--disable-windowed-traceback</code> 参数用于禁用异常提示。</p><p>如果不添加这个参数，当程序代码中报错的时候，会弹出一个窗口报告异常信息（注意：仅在隐藏控制台模式下弹出异常报告窗口）。</p><p><img src="`+e+'" alt="python_20240528154932.png"></p><h2 id="编译打包的问题" tabindex="-1">编译打包的问题 <a class="header-anchor" href="#编译打包的问题" aria-label="Permalink to &quot;编译打包的问题&quot;">​</a></h2><h3 id="闪退问题" tabindex="-1">闪退问题 <a class="header-anchor" href="#闪退问题" aria-label="Permalink to &quot;闪退问题&quot;">​</a></h3><p>当编译打包后，双击exe文件。却发现程序闪退。</p><blockquote><p>解决方法</p></blockquote><ol><li>先进入到exe文件的目录，打开终端。输入exe文件的全称。</li></ol><p>可以看到该exe文件运行闪退的原因。 <img src="'+h+'" alt="python_20240528170031.png"></p><ol start="2"><li>如果提示缺少模块，可能是你的项目文件中的虚拟环境中有模块，但是你安装在本机的python环境，却没有这个模块。那么就直接安装即可。</li></ol><p>可以用 pip list 命令查询你本机安装的python模块。</p><h3 id="python虚拟环境-缺少模块的问题" tabindex="-1">python虚拟环境，缺少模块的问题 <a class="header-anchor" href="#python虚拟环境-缺少模块的问题" aria-label="Permalink to &quot;python虚拟环境，缺少模块的问题&quot;">​</a></h3><p>python项目是区分本地环境和虚拟环境。</p><p>当对某个python项目，在本地的终端中，使用pyinstaller进行打包。并且这个python项目是使用的虚拟环境的模块库。</p><p>那么打包后的exe文件可能缺少模块，因为缺少的模块库在虚拟环境存在，但是在本地环境不存在。</p><blockquote><p>解决方法</p></blockquote><ol><li>在这个python项目使用的虚拟环境中，安装 pyinstaller 打包工具。</li><li>安装完毕后,虚拟环境中的 scripte文件夹下会增加一个pyinstaller.exe程序</li><li>然后在这个python项目的终端中，再次运行打包命令。</li></ol>',80)]))}const u=i(k,[["render",r]]);export{F as __pageData,u as default};
