import{_ as l,c as e,o as t,ak as i}from"./chunks/framework.CmzJUe0_.js";const m=JSON.parse('{"title":"消息队列面试题总结","description":"","frontmatter":{"title":"消息队列面试题总结","date":"2023-12-10T00:00:00.000Z","sidebar":"auto","categories":["面试"],"tags":["微服务"]},"headers":[],"relativePath":"blogs/面试/消息队列面试题总结.md","filePath":"blogs/面试/消息队列面试题总结.md"}'),o={name:"blogs/面试/消息队列面试题总结.md"};function r(s,a,_,n,d,c){return t(),e("div",null,a[0]||(a[0]=[i('<p>[toc]</p><h1 id="消息队列面试题总结" tabindex="-1">消息队列面试题总结 <a class="header-anchor" href="#消息队列面试题总结" aria-label="Permalink to &quot;消息队列面试题总结&quot;">​</a></h1><h2 id="为什么使用mq-mq的优点" tabindex="-1">为什么使用MQ？MQ的优点？ <a class="header-anchor" href="#为什么使用mq-mq的优点" aria-label="Permalink to &quot;为什么使用MQ？MQ的优点？&quot;">​</a></h2><p>使用的MQ的好处就是：异步，解耦，流量削峰。</p><ul><li>异步：微服务中，一个业务功往往涉及到多个服务。而完成一个业务功能，往往需要按步骤完成多个服务（例如先完成服务A-》再完成服务B-》最后完成服务C），这需要花费一些时间。而MQ提供的异步消息，可以让我们同时完成多个服务（同时完成服务ABC），这样可以减少业务功能的完成时间。</li><li>解耦：通过消息队列，可以将服务与服务之间的耦合，转换为服务与消息队列之间的耦合。降低了服务之间的耦合度。</li><li>流量削峰：对于MQ来说，服务与服务之间的调用，就相当于互相之间发消息。可以利用消息队列的特性，来缓解消息的发送量。相当于缓解服务的请求并发量。例如延时消息等。</li></ul><h2 id="mq有什么优缺点" tabindex="-1">MQ有什么优缺点？ <a class="header-anchor" href="#mq有什么优缺点" aria-label="Permalink to &quot;MQ有什么优缺点？&quot;">​</a></h2><ul><li><p>系统可用性降低：由于系统中服务之间的调用，从之前的直接调用，变成了依赖MQ的调用。这样会导致系统的可用性降低。</p></li><li><p>系统复杂度提高</p><ul><li>如何保证消息传输的可靠性？</li><li>如何保证消息不被重复消费?</li><li>消息消费失败后,业务如何回滚？</li></ul></li></ul><h2 id="mq有哪些常见问题" tabindex="-1">MQ有哪些常见问题？ <a class="header-anchor" href="#mq有哪些常见问题" aria-label="Permalink to &quot;MQ有哪些常见问题？&quot;">​</a></h2><p>常用问题主要有两个？</p><ol><li>如何保证有序消息的有序生产和有序消费？</li><li>如何保证消息不被重复消费?</li></ol>',10)]))}const p=l(o,[["render",r]]);export{m as __pageData,p as default};
