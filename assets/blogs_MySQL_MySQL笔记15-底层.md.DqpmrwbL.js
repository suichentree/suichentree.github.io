import{_ as t,c as i,o as a,ak as e}from"./chunks/framework.CmzJUe0_.js";const l="/assets/mysql_20231219170508.7_zmEa7N.png",y=JSON.parse('{"title":"MySQL笔记15-底层","description":"","frontmatter":{"title":"MySQL笔记15-底层","date":"2022-12-19T00:00:00.000Z","sidebar":"auto","categories":["数据库"],"tags":["MySql"]},"headers":[],"relativePath":"blogs/MySQL/MySQL笔记15-底层.md","filePath":"blogs/MySQL/MySQL笔记15-底层.md"}'),d={name:"blogs/MySQL/MySQL笔记15-底层.md"};function h(r,s,p,n,o,k){return a(),i("div",null,s[0]||(s[0]=[e('<p>[toc]</p><h1 id="mysql笔记15-底层" tabindex="-1">MySQL笔记15-底层 <a class="header-anchor" href="#mysql笔记15-底层" aria-label="Permalink to &quot;MySQL笔记15-底层&quot;">​</a></h1><h2 id="mysql架构" tabindex="-1">MySQL架构 <a class="header-anchor" href="#mysql架构" aria-label="Permalink to &quot;MySQL架构&quot;">​</a></h2><p>MySQL架构图如下所示 <img src="'+l+`" alt="mysql_20231219170508.png"></p><h3 id="客户端连接器" tabindex="-1">客户端连接器 <a class="header-anchor" href="#客户端连接器" aria-label="Permalink to &quot;客户端连接器&quot;">​</a></h3><p>客户端连接器负责与客户端进行通信。客户端连接器主要对接各个MySQL客户端。例如JDBC，navicat等。</p><h3 id="连接池" tabindex="-1">连接池 <a class="header-anchor" href="#连接池" aria-label="Permalink to &quot;连接池&quot;">​</a></h3><p>连接池主要是存储和管理，客户端与服务端的数据库连接，一个数据库连接代表一个线程。。</p><p>当客户端与服务端建立好连接后，客户端就可以向服务端发送SQL语句了。</p><h3 id="缓存" tabindex="-1">缓存 <a class="header-anchor" href="#缓存" aria-label="Permalink to &quot;缓存&quot;">​</a></h3><p>缓存会记录Mysql执行过的查询语句，以key-value键值对的方式存储在缓存中。key是查询语句，value是查询结果。</p><ol><li>当Mysql服务端接收到客户端发过来的SQL语句后，如果是一个查询SQL语句，那么服务端会首先到缓存中查找是否存在过这个查询SQL语句。</li><li>如果SQL语句在缓存中，则直接从缓存中把查询结果返回给客户端。</li><li>如果SQL语句不在缓存中，则执行后面步骤。并将查询结果存入缓存中。</li></ol><p>缓存的缺点：建议不要使用查询缓存，因为查询缓存的失效非常频繁</p><p><span style="color:red;">注意：MySQL 8.0版本直接将缓存的整块功能删掉了，标志着MySQL8.0开始彻底没有缓存这个功能了。</span></p><h3 id="解析器" tabindex="-1">解析器 <a class="header-anchor" href="#解析器" aria-label="Permalink to &quot;解析器&quot;">​</a></h3><p>如果SQL语句没有命中查询缓存，那么服务端中的解析器会对客户端传来的SQL语句进行解析。</p><ol><li>服务端中的解析器会对SQL语句进行解析。</li><li>解析器会对SQL语句进行解析。例如把关键字从SQL语句中提取出来。</li><li>解析器也会判断SQL语句是否出现语法错误。</li></ol><p>如果解析器对SQL语句解析后，没有报错。此时SQL语句会进入优化器。</p><h3 id="优化器" tabindex="-1">优化器 <a class="header-anchor" href="#优化器" aria-label="Permalink to &quot;优化器&quot;">​</a></h3><p>当解析器将SQL语句解析完成后，如果没有报错。说明SQL语句是符合语法并且可以执行的。此时解析器会把SQL语句传递给优化器。</p><p>优化器会对SQL语句进行优化。</p><p>若表有个组合索引（A,B,C）。当SQL语句是<code>select ... where B=x and A=x and C=x</code>。如果按照最左前缀原则，这个查询语句是不会触发组合索引的。但是优化器会把这个SQL语句优化为<code>select ... where A=x and B=x and C=x</code>。</p><p>当优化器将SQL语句优化完之后，会把优化后的SQL语句传递给执行器。</p><h3 id="执行器" tabindex="-1">执行器 <a class="header-anchor" href="#执行器" aria-label="Permalink to &quot;执行器&quot;">​</a></h3><p>当执行器接收到优化器传递的SQL语句后，执行器会调用对应的存储引擎执行 SQL语句。主流的是MyISAM 和 Innodb 存储引擎。</p><h3 id="存储引擎" tabindex="-1">存储引擎 <a class="header-anchor" href="#存储引擎" aria-label="Permalink to &quot;存储引擎&quot;">​</a></h3><p>存储引擎是真正执行SQL语句的。</p><h3 id="物理文件存储层" tabindex="-1">物理文件存储层 <a class="header-anchor" href="#物理文件存储层" aria-label="Permalink to &quot;物理文件存储层&quot;">​</a></h3><p>物理存储层主要是将数据库的数据和日志存储在文件中，并与存储引擎打交道。</p><p>物理文件主要包括：数据文件，日志文件，配置文件，pid文件等。</p><p>数据文件是指：.ibd文件或.ibdata文件等，这些是存放数据或存放索引的文件。</p><p>日志文件是指：错误日志，bin日志等。</p><p>配置文件是指：存放MySQL所有的配置信息的文件，比如：my.cnf、my.ini等。</p><p>pid文件是指：进程文件，即mysql中的可执行文件等。</p><h2 id="sql语句中的关键字的执行方式" tabindex="-1">SQL语句中的关键字的执行方式 <a class="header-anchor" href="#sql语句中的关键字的执行方式" aria-label="Permalink to &quot;SQL语句中的关键字的执行方式&quot;">​</a></h2><p>假如有三张表。分别是学生表，课程表，成绩表。</p><p>学生表（t_student）</p><table tabindex="0"><thead><tr><th>sid</th><th>sname</th><th>age</th><th>sex</th></tr></thead><tbody><tr><td>1</td><td>小明</td><td>12</td><td>男</td></tr><tr><td>2</td><td>小黑</td><td>13</td><td>男</td></tr><tr><td>3</td><td>小白</td><td>11</td><td>女</td></tr></tbody></table><p>课程表（t_course）</p><table tabindex="0"><thead><tr><th>cid</th><th>cname</th></tr></thead><tbody><tr><td>1</td><td>语文</td></tr><tr><td>2</td><td>数学</td></tr><tr><td>3</td><td>英语</td></tr></tbody></table><p>成绩表(t_score)，sid为学生编号，cid为课程编号</p><table tabindex="0"><thead><tr><th>sid</th><th>cid</th><th>score</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>55</td></tr><tr><td>1</td><td>2</td><td>67</td></tr><tr><td>1</td><td>3</td><td>86</td></tr><tr><td>2</td><td>1</td><td>66</td></tr><tr><td>2</td><td>2</td><td>78</td></tr><tr><td>2</td><td>3</td><td>87</td></tr></tbody></table><h3 id="group-by-的执行方式" tabindex="-1">group by 的执行方式 <a class="header-anchor" href="#group-by-的执行方式" aria-label="Permalink to &quot;group by 的执行方式&quot;">​</a></h3><h4 id="普通的group-by语句" tabindex="-1">普通的group by语句 <a class="header-anchor" href="#普通的group-by语句" aria-label="Permalink to &quot;普通的group by语句&quot;">​</a></h4><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 根据sid字段值对t_score表的记录进行分组。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t_score </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">group by</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> sid</span></span></code></pre></div><p>执行结果如下</p><table tabindex="0"><thead><tr><th>sid</th><th>cid</th><th>score</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>55</td></tr><tr><td>2</td><td>1</td><td>66</td></tr></tbody></table><p>执行流程：</p><ol><li>先执行 from t_score 语句，得到临时表1</li><li>然后对 临时表1 执行 group by sid。即根据sid字段对临时表1进行分组。 <ol><li>先创建一个临时表2，然后全表读取临时表1的数据。</li><li>先读取临时表1的第一条行记录，有没有sid字段的值。如果有就把行记录加入到临时表2中。</li><li>继续读取临时表1的行记录。如果有与临时表2的sid字段不一样的值，才加入到临时表2中。否则不加入。</li></ol></li><li>最终临时表2的数据才是SQL的结果集。</li></ol><p><code>group by sid</code>相当于针对sid字段进行数据去重。如果表中有多条sid相同的行记录，那么group by只会使用第一条行记录。因此效果相当于去重。</p><h4 id="带有where的group-by语句" tabindex="-1">带有where的group by语句 <a class="header-anchor" href="#带有where的group-by语句" aria-label="Permalink to &quot;带有where的group by语句&quot;">​</a></h4><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 第一步：查询出score&gt;60的t_score表的记录。形成临时表1</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 第二步：根据sid字段值对临时表1的记录进行分组</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t_score </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> score </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 60</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> group by</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> sid</span></span></code></pre></div><p><span style="color:red;">注意：where 必须写在 group by 之前。并且 where 也是在 group by 之前执行的。</span></p><p>执行结果如下</p><table tabindex="0"><thead><tr><th>sid</th><th>cid</th><th>score</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>67</td></tr><tr><td>2</td><td>1</td><td>66</td></tr></tbody></table><p>执行流程：</p><ol><li>先执行 from t_score where score &gt; 60 语句，得到临时表1。</li><li>然后对 临时表1 执行 group by sid。即根据sid字段对临时表1进行分组。 <ol><li>先创建一个临时表2，然后全表读取临时表1的数据。</li><li>先读取临时表1的第一条行记录，有没有sid字段的值。如果有就把行记录加入到临时表2中。</li><li>继续读取临时表1的行记录。如果有与临时表2的sid字段不一样的值，才加入到临时表2中。否则不加入。</li></ol></li><li>最终临时表2的数据才是SQL的结果集。</li></ol><h4 id="带有聚合函数的group-by语句" tabindex="-1">带有聚合函数的group by语句 <a class="header-anchor" href="#带有聚合函数的group-by语句" aria-label="Permalink to &quot;带有聚合函数的group by语句&quot;">​</a></h4><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 第一步：查询出t_score表的记录。形成临时表1</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 第二步：根据sid字段值对临时表1的记录进行分组</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 第三步：在分组的过程中，将相同的sid字段值的行记录的score字段值进行sum函数求和。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> sid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(score) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t_score </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">group by</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> sid</span></span></code></pre></div><p>执行结果如下</p><table tabindex="0"><thead><tr><th>sid</th><th>sum(score)</th></tr></thead><tbody><tr><td>1</td><td>208</td></tr><tr><td>2</td><td>231</td></tr></tbody></table><p>执行流程：</p><ol><li>先执行 from t_score 语句，得到临时表1。</li><li>然后对 临时表1 执行 group by sid。即根据sid字段对临时表1进行分组。 <ol><li>先创建一个临时表2，这个临时表2有sid和sum(score)两个字段。然后开始全表读取临时表1。</li><li>先读取临时表1的第一条行记录，有没有sid字段的值。如果有就把行记录加入到临时表2中。并将socre字段的值加入到sum(score)中。</li><li>继续读取临时表1的行记录。如果有与临时表2的sid字段一样的值，就将score字段值，加入到sum(score)中。如果有不一样的sid字段值，则把这条行记录加入到临时表2中。</li><li>依次类推</li></ol></li><li>最终临时表2的数据才是SQL的结果集。</li></ol><h4 id="带有-having-的group-by语句" tabindex="-1">带有 HAVING 的group by语句 <a class="header-anchor" href="#带有-having-的group-by语句" aria-label="Permalink to &quot;带有 HAVING 的group by语句&quot;">​</a></h4><div class="language-sql vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sql</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 第一步：查询出t_score表的记录。形成临时表1</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 第二步：根据sid字段值对临时表1的记录进行分组</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 第三步：在分组的过程中，将相同的sid字段值的行记录的score字段值进行sum函数求和。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">-- 第四步：最后筛选出num字段大于210的记录</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">select</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> sid</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(score) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t_score </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">group by</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> sid</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> HAVING</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 210</span></span></code></pre></div><p>执行结果如下</p><table tabindex="0"><thead><tr><th>sid</th><th>sum(score)</th></tr></thead><tbody><tr><td>2</td><td>231</td></tr></tbody></table><p>执行流程：</p><ol><li>先执行 from t_score 语句，得到临时表1。</li><li>然后对 临时表1 执行 group by sid。即根据sid字段对临时表1进行分组。 <ol><li>先创建一个临时表2，这个临时表2有sid和sum(score)两个字段。然后开始全表读取临时表1。</li><li>先读取临时表1的第一条行记录，有没有sid字段的值。如果有就把行记录加入到临时表2中。并将socre字段的值加入到sum(score)中。</li><li>继续读取临时表1的行记录。如果有与临时表2的sid字段一样的值，就将score字段值，加入到sum(score)中。如果有不一样的sid字段值，则把这条行记录加入到临时表2中。</li><li>依次类推</li></ol></li><li>最后对临时表2的记录，筛选出num字段大于210的记录</li></ol><p><span style="color:red;">注意：先执行 where ,后执行 group by ,最后执行 having。</span></p>`,70)]))}const b=t(d,[["render",h]]);export{y as __pageData,b as default};
